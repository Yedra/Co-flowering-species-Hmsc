---
title: "D.lapponica: Selection analyses via fruit set"
author: '"Yedra Garcia"'
date: "2023-12-06"
output: html_document
---

```{r, eval=FALSE}
library(tidyverse)
library(Hmsc)
library(abind)
library(mgcv)
library(knitr)
library(ggplot2)
library(reshape2)
library(data.table)
library(ggpubr)
```

#Here



Loading trait (include fruit information) and co-flowering community data
```{r, , eval=FALSE}

traitdata<- read.csv("data/data_CRO/Gotland_trait_data.csv", header=T, sep= ";", dec=",") %>% mutate(individual= as.character(individual))%>%select(-c(18:23))#remove some columns at the end

commudata<-read.csv("data/data_CRO/Gotland_community_data.csv", header= T, sep= ";", fileEncoding="latin1")%>% mutate(individual= as.character(individual), Primula_farinosa= as.integer(factor(Primula_farinosa)))%>% select(-c(57:60))##remove extra-columns

```

Remove unnecessary columns and rename trait variables

```{r pressure, echo=FALSE}
dat= traitdata %>% select(-c(2:5, 14))%>%
  rename(height= height_cm, flower_size= flower_size_mm, spur_length= spur_length_mm, spur_width= spur_width_mm, flowers= No_of_flowers)

```

Check for outliers
```{r, fig.width= 7, fig.height= 6, echo= F, warning= F}

par(mfrow= c(3,3))
hist(dat$height)
hist(dat$flower_size)
hist(dat$spur_length)
hist(dat$spur_width)
hist(dat$flowers_open)
hist(dat$flowers)

#Exclude individuals with flower size <=2 mm

data= dat %>% filter(!dat$flower_size <=2)
```
Summary statistics

```{r, echo= F, warning= F}
summary_stats= data %>%
  summarise_at(vars(-c(1, 3:5, 12)), list(mean= mean, sd= sd), na.rm= TRUE)%>%
  pivot_longer(cols = everything(), 
       names_to = c("trait", ".value"), names_pattern = '(.*)_(\\w+)')

summst= summary_stats %>%mutate( cv= mean/sd)

kable(summst)
```

Phenotypic correlation matrix
```{r, echo= F}
P = cor(cbind(data$height, data$flower_size, data$spur_length, data$spur_width, data$flowers_open), use="pairwise")
colnames(P) = rownames(P) = c("height", "flower_size", "spur_length", "spur_width",
                              "open flowers")
signif(P, 3)
```
Merge trait-fruit data with community data

```{r, echo= F, warning= F}
all_data<-merge(data, commudata, by= "individual", all.x= TRUE)

```

#Abundance and prevalence of co-flowering species
```{r, fig.width= 6, fig.height= 6, echo= F}
#Abundances of the co-flowering species
sort(colSums(all_data[, 13:67]))

coflow= all_data[, 13:67]
preval= colMeans(coflow>0)
mean(preval)
abund= colSums(coflow)/colSums(coflow>0)

par(mfrow=c(2,2))
hist(preval)
hist(abund)
```
####HMSC model

To estimate the effects of the co-flowering community on relative reproductive fitness (fruit number) of D. lapponica, we set up a HMSC model in which we follow a reduced-rank regression approach (RRR) that reduces the number of dimensions of the animal-pollinated co-flowering species in the community and select those that best explain variation in the response (i.e., relative fruit set). In addition, we include as standard predictors in the HMSC model five phenotypic traits, thus we also estimate the selection gradients for each trait while accounting for effects of the co-flowering community. 
 

To test our model=m, we compare it with three alternative models: 1) a model that only includes the five traits as predictors= m1, 2) a model that includes the five traits and each animal-pollinated co-floweing species as predictors (Opedal et al 2022. J Evol Biol)= m2, and 3) a model that includes the five traits and a reduced rank regression of the non-animal pollinated co-flowering community= m3.

```{r, echo= F}
#HMSC
indat= na.omit(all_data)##157 individuals

#Define the response variable
Y= cbind(indat$fruit_number)
hist(Y)

#Define XData: height, flower size, spur length, spur width, open flowers
XData= indat[, c(2,6,7,8,11)]
head(XData)
cor(XData)
```

Select the animal-pollinated coflowering species within the coflowering community

```{r, echo= F}

coflo_data= indat[, 13:67]# co-flowering species

## Animal-pollinated co-flowering species

anim= c("Potentilla_erecta", "Primula_farinosa", "Pinguicula_vulgaris", "Succisa_pratensis", "Centaurea_jacea", "Prunella_grandiflora", "Prunella_vulgaris",
"Prunella_grandifloraxvulgaris", "Polygala_amarella", "Centarium_littorale", "Parnassia_palustris", "Antennaria_dioica", "Linum_catharticum", "Galium_boreale",
"Tetragonolobus_maritimus", "Scorzonera_humilis", "Tofieldia.calyculata", "Anthericum_ramosum", "Epipactis_palustris", "Platanthera_bifolia", "Gymnadenia_conopsea", "Gymnadenia_densiflora", "Gymnadenia_odoratissima", "Dactylorhiza_majalis_lapponica", "Inula.salicina", "Gentianella_uliginosa_cf", "Frangula_alnus_smallplant",
"Euphrasia_salisburgensis", "Vaccinium_vitis.idaea", "Asperula_tinctoria",
"Gymnadenia_sp", "Allium_schoenoprasum", "Leontodon_autumnalis", "Potentilla_reptans", "Calluna_vulgaris", "Dactylorhiza_incarnata_cruenta")

```

Define the XRRRData for the subset of the animal-pollinated species, and remove singletons (species only found close to one D. lapponica individual)
```{r, echo=FALSE}
XRRRData = coflo_data[, colnames(coflo_data) %in% anim]

XRRRData = XRRRData[, match(anim, colnames(XRRRData))]
head(XRRRData)

#sort(colSums(XRRRData))

XRRRData = XRRRData[, colSums(XRRRData>=1) >1]# Remove singletons
length(XRRRData)#28 species in more than one sampling unit
```

Define the Xformula with the trait predictors (= XData)

```{r}
XFormula = as.formula(paste("~", paste0(colnames(XData), collapse=" + ")))
XFormula

```

Define the XRRRformula with the animal-pollinated species (= XRRRData) 

```{r}
XRRRFormula = as.formula(paste("~", " -1 + ", paste0(colnames(XRRRData), collapse=" + ")))
XRRRFormula
```
Scale the XRRRData (the animal-pollinated co-flowering species)

```{r}
XRRRDataScaled = data.frame(scale(XRRRData))
dim(XRRRData)
```

Fit the HMSC models.

#HMSC with traits and the RRR of the animal-pollinated species as predictors (m)

```{r}

m = Hmsc(Y = as.matrix(Y/mean(Y)), XData=XData, XFormula=XFormula,
         distr="normal", 
         XRRRData=XRRRDataScaled, XRRRFormula=XRRRFormula, ncRRR=1, XRRRScale = TRUE)
```
#Alternative models:

#HMSC only with traits as predictors (m1)
```{r}
m1 = Hmsc(Y = as.matrix(Y/mean(Y)), XData=XData, XFormula=XFormula,
          distr="normal")
```

#HMSC with traits and each animal-pollinated species as predictors (m2)

Here, we need another XData object (= XData2) that includes the traits and each animal-poll co-flowering species (XRRRData) and define an Xformula for it (= XFormula2)
```{r}
XData2 = data.frame(XData, XRRRData)
XFormula2 = as.formula(paste("~", paste0(colnames(XData2), collapse=" + ")))
XFormula2

m2 = Hmsc(Y = as.matrix(Y/mean(Y)), XData=XData2, XFormula=XFormula2,
          distr="normal")
```

#HMSC with traits and the RRR of the non-animal pollinated species as predictors (m3)

Here, we need another XRRRData object (= XRRRData2) for the non-animal pollinated species. As we did before, we remove singletons and scale the XRRRRData2 object.

Then we define the XRRRformula (XRRRFormula2)

```{r}
XRRRData2= coflo_data[!(colnames(coflo_data) %in% anim)]

XRRRData2 = XRRRData2[, colSums(XRRRData2>=1) >1]# 10 sp wihout singletons

XRRRDataScaled2 = data.frame(scale(XRRRData2))
dim(XRRRData2)

XRRRFormula2 = as.formula(paste("~", " -1 + ", paste0(colnames(XRRRData2), collapse=" + ")))

XRRRFormula2

m3 = Hmsc(Y = as.matrix(Y/mean(Y)), XData=XData, XFormula=XFormula,
         distr="normal", XRRRData= XRRRDataScaled2, XRRRFormula=XRRRFormula2, ncRRR=1, XRRRScale = TRUE)
```

Now we set the sampling parameters and fit the four models.
```{r, echo=FALSE}
samples = 1000
thin = 100
transient = .5*(thin*samples)
adaptNf = 0.4*(thin*samples)
nChains = 1

models= list(m, m1, m2, m3)
for(i in 1:4){
  models[[i]]= sampleMcmc(models[[i]], samples = samples, thin = thin, adaptNf=rep(adaptNf, m$nr), 
               transient = transient, nChains = nChains)}

#save(models, file ="analyses/models_fset_lap.RData")

load(file ="analyses/models_fset_lap.RData")

```
Check effective sample sizes

```{r, echo=FALSE}

post= convertToCodaObject(models[[1]], covNamesNumbers = c(T,F))
post1= convertToCodaObject(models[[2]], covNamesNumbers = c(T,F))
post2= convertToCodaObject(models[[3]], covNamesNumbers = c(T,F))
post3= convertToCodaObject(models[[4]], covNamesNumbers = c(T,F))

effectiveSize(post$Beta)

```
#Asess MCMC convergence and get posterior support for Beta of the co-flowering community

```{r}
#Posterior support for the RRR animal-pollinated coflowering community
getPostEstimate(models[[1]], "Beta")

postsup= getPostEstimate(models[[1]], "Beta")$support[7, ]

postsup[which(postsup<0.5)] = 1 - postsup[which(postsup<0.5)]
postsup
```

MCMC convergence
```{r}
plot(post$Beta[,7])
```


```{r}
# Temp. posterior of wRRR
bind0 = function(...) {abind(..., along = 0)}
postList = poolMcmcChains(models[[1]]$postList, chainIndex = 1:length(models[[1]]$postList), 
                          start = 1, thin = 1)
valList = lapply(postList, function(a) a[["wRRR"]])
wRRR_post = do.call(bind0, valList)

dim(wRRR_post)

for(i in 1:28){
  plot(wRRR_post[,1,i], type="l")
}

```
#Model fitting

Now we evaluate the explanatory power of the model "m" by computing the R^2 values and compare with alternative models (m1, m2 and m3)
```{r}

MF_results= matrix(NA, nrow= 2, ncol= 4)
for(i in 1:4){
  m= models[[i]]
  pred= computePredictedValues(m)
        MF= evaluateModelFit(hM= m, predY = pred)
        MF_results[1,i]= mean(MF$R2)
}

MF_results
```
Now we evaluate the predictive power of the model "m" and of the alternative models by using 5-fold cross validation


```{r}
partition= createPartition(m, nfolds=5)

for(i in 1:4){
  m= models[[i]]
  pred_CV = computePredictedValues(m, partition)
  MF_CV= evaluateModelFit(hM= m, predY = pred_CV)
  MF_results[2, i]= mean(MF_CV$R2)
}

MF_results

colnames(MF_results)= c("RRRco", "MR", "MRco", "RRRn")
rownames(MF_results)=  c("MF", "MF_cV")

MF_results= as.data.frame(MF_results)

save(MF_results, file="results/MF_fset_lap.RData")
```

#Obtain the selection gradients for m

```{r}
nX = ncol(models[[1]]$XData)
nX

#beta_raw_post = post$Beta[,2:(nX+1)][[1]] #posterior for betas
beta_raw_post = post$Beta[,2:(5+1)][[1]]
head(beta_raw_post)

beta_var_post = matrix(NA, nrow=nrow(beta_raw_post), ncol=nX)
for(i in 1:nX){
  beta_var_post[,i] = beta_raw_post[,i]*sd(XData[,i])
}

beta_mean_post = matrix(NA, nrow=nrow(beta_raw_post), ncol=nX)
for(i in 1:nX){
  beta_mean_post[,i] = beta_raw_post[,i]*mean(XData[,i])
}

beta_raw = apply(beta_raw_post, 2, mean)
beta_raw_lower = apply(beta_raw_post, 2, quantile, c(0.025))
beta_raw_upper = apply(beta_raw_post, 2, quantile, c(0.975))

beta_var = apply(beta_var_post, 2, mean)
beta_var_lower = apply(beta_var_post, 2, quantile, c(0.025))
beta_var_upper = apply(beta_var_post, 2, quantile, c(0.975))

beta_mean = apply(beta_mean_post, 2, mean)
beta_mean_lower = apply(beta_mean_post, 2, quantile, c(0.025))
beta_mean_upper = apply(beta_mean_post, 2, quantile, c(0.975))

resmat_RRR = data.frame(beta_raw = round(beta_raw, 3),
                        L = round(beta_raw_lower, 3),
                        U = round(beta_raw_upper, 3),
                        beta_var = round(beta_var, 3),
                        L = round(beta_var_lower, 3),
                        U = round(beta_var_upper, 3),
                        beta_mean = round(beta_mean*100, 3),
                        L = round(beta_mean_lower, 3),
                        U = round(beta_mean_upper, 3))

betaRRR = post$Beta[,(nX+2):(models[[1]]$ncRRR+(nX+1))][[1]] #posterior for beta_RRR
#betaRRR = post$Beta[,(5+2):(m$ncRRR+(5+1))][[1]] #posterior for beta_RRR
length(betaRRR)

# The anim-pollinated co-flowering community axis"
dim(models[[1]]$XRRR)

comp1_post = matrix(NA, nrow=length(betaRRR), ncol=models[[1]]$ny)
for(i in 1:length(betaRRR)){
  comp1_post[i,]=models[[1]]$XRRR %*% as.matrix((wRRR_post[i,1,]))
}

beta_comp1_post=NULL
for(i in 1:1000){
  beta_comp1_post[i]=betaRRR[i]*sd(comp1_post[i,])
}

resmat_RRR[nrow(resmat_RRR)+1,]=c("NA","NA","NA", 
                 round(mean(beta_comp1_post), 3),
                 round(quantile(beta_comp1_post, c(0.025)), 3),
                 round(quantile(beta_comp1_post, c(0.975)), 3),
                 "NA","NA","NA")
kable(resmat_RRR)

```

#Obtain selection gradients for m1

```{r, echo=FALSE}
nX = ncol(models[[2]]$XData)
nX

#beta_raw_post = post$Beta[,2:(nX+1)][[1]] #posterior for betas
beta_raw_post = post1$Beta[,2:(5+1)][[1]]

head(beta_raw_post)

beta_var_post = matrix(NA, nrow=nrow(beta_raw_post), ncol=nX)
for(i in 1:nX){
  beta_var_post[,i] = beta_raw_post[,i]*sd(XData[,i])
}

beta_mean_post = matrix(NA, nrow=nrow(beta_raw_post), ncol=nX)
for(i in 1:nX){
  beta_mean_post[,i] = beta_raw_post[,i]*mean(XData[,i])
}

beta_raw = apply(beta_raw_post, 2, mean)
beta_raw_lower = apply(beta_raw_post, 2, quantile, c(0.025))
beta_raw_upper = apply(beta_raw_post, 2, quantile, c(0.975))

beta_var = apply(beta_var_post, 2, mean)
beta_var_lower = apply(beta_var_post, 2, quantile, c(0.025))
beta_var_upper = apply(beta_var_post, 2, quantile, c(0.975))

beta_mean = apply(beta_mean_post, 2, mean)
beta_mean_lower = apply(beta_mean_post, 2, quantile, c(0.025))
beta_mean_upper = apply(beta_mean_post, 2, quantile, c(0.975))


resmat_M1 = data.frame(beta_raw = round(beta_raw, 3),
                        L = round(beta_raw_lower, 3),
                        U = round(beta_raw_upper, 3),
                        beta_var = round(beta_var, 3),
                        L = round(beta_var_lower, 3),
                        U = round(beta_var_upper, 3),
                        beta_mean = round(beta_mean*100, 3),
                        L = round(beta_mean_lower, 3),
                        U = round(beta_mean_upper, 3))

resmat_M1[nrow(resmat_M1)+1,]= rep(c("NA"), times= 9)


kable(resmat_M1)
```
Selection gradients for m2

```{r, echo=FALSE}
nX = ncol(models[[3]]$XData)
nX

beta_raw_post = post2$Beta[,2:(5+1)][[1]] #posterior for betas
#beta_raw_post = post2$Beta[,2:(33+1)][[1]] 
head(beta_raw_post)


beta_var_post = matrix(NA, nrow=nrow(beta_raw_post), ncol=ncol(beta_raw_post))
  for(i in 1:ncol(beta_raw_post)){
    beta_var_post[,i] = beta_raw_post[,i]*sd(models[[3]]$XData[,i])
  }
  
  beta_mean_post = matrix(NA, nrow=nrow(beta_raw_post), ncol=ncol(beta_raw_post))
  for(i in 1:ncol(beta_raw_post)){
    beta_mean_post[,i] = beta_raw_post[,i]*mean(models[[3]]$XData[,i])
  }

beta_raw = apply(beta_raw_post, 2, mean)
beta_raw_lower = apply(beta_raw_post, 2, quantile, c(0.025))
beta_raw_upper = apply(beta_raw_post, 2, quantile, c(0.975))

beta_var = apply(beta_var_post, 2, mean)
beta_var_lower = apply(beta_var_post, 2, quantile, c(0.025))
beta_var_upper = apply(beta_var_post, 2, quantile, c(0.975))

beta_mean = apply(beta_mean_post, 2, mean)
beta_mean_lower = apply(beta_mean_post, 2, quantile, c(0.025))
beta_mean_upper = apply(beta_mean_post, 2, quantile, c(0.975))


resmat_M2 = data.frame(beta_raw = round(beta_raw, 3),
                        L = round(beta_raw_lower, 3),
                        U = round(beta_raw_upper, 3),
                        beta_var = round(beta_var, 3),
                        L = round(beta_var_lower, 3),
                        U = round(beta_var_upper, 3),
                        beta_mean = round(beta_mean*100, 3),
                        L = round(beta_mean_lower, 3),
                        U = round(beta_mean_upper, 3))
resmat_M2[nrow(resmat_M2[,])+1,]= rep(c("NA"), times= 9)

kable(resmat_M2)
```
#Selection gradients for model with RRR of non-animal-pollinated species

```{r, echo=FALSE}
nX = ncol(models[[4]]$XData)
nX

#beta_raw_post = post$Beta[,2:(nX+1)][[1]] #posterior for betas
beta_raw_post = post3$Beta[,2:(5+1)][[1]]
head(beta_raw_post)

beta_var_post = matrix(NA, nrow=nrow(beta_raw_post), ncol=nX)
for(i in 1:nX){
  beta_var_post[,i] = beta_raw_post[,i]*sd(XData[,i])
}

beta_mean_post = matrix(NA, nrow=nrow(beta_raw_post), ncol=nX)
for(i in 1:nX){
  beta_mean_post[,i] = beta_raw_post[,i]*mean(XData[,i])
}

beta_raw = apply(beta_raw_post, 2, mean)
beta_raw_lower = apply(beta_raw_post, 2, quantile, c(0.025))
beta_raw_upper = apply(beta_raw_post, 2, quantile, c(0.975))

beta_var = apply(beta_var_post, 2, mean)
beta_var_lower = apply(beta_var_post, 2, quantile, c(0.025))
beta_var_upper = apply(beta_var_post, 2, quantile, c(0.975))

beta_mean = apply(beta_mean_post, 2, mean)
beta_mean_lower = apply(beta_mean_post, 2, quantile, c(0.025))
beta_mean_upper = apply(beta_mean_post, 2, quantile, c(0.975))

resmat_M3 = data.frame(beta_raw = round(beta_raw, 3),
                        L = round(beta_raw_lower, 3),
                        U = round(beta_raw_upper, 3),
                        beta_var = round(beta_var, 3),
                        L = round(beta_var_lower, 3),
                        U = round(beta_var_upper, 3),
                        beta_mean = round(beta_mean*100, 3),
                        L = round(beta_mean_lower, 3),
                        U = round(beta_mean_upper, 3))
#resmat_M3[nrow(resmat_M3[,])+1,]= rep(c("NA"), times= 9)

#####
betaRRR = post3$Beta[,(nX+2):(models[[4]]$ncRRR+(nX+1))][[1]] #posterior for beta_RRR
#betaRRR = post$Beta[,(5+2):(m$ncRRR+(5+1))][[1]] #posterior for beta_RRR
length(betaRRR)

# The non-anim-pollinated co-flowering community axis"
dim(models[[4]]$XRRR)

# Temp. posterior of wRRR
bind0 = function(...) {abind(..., along = 0)}
postList = poolMcmcChains(models[[4]]$postList, chainIndex = 1:length(models[[4]]$postList), 
                          start = 1, thin = 1)
valList = lapply(postList, function(a) a[["wRRR"]])
wRRR_postn = do.call(bind0, valList)

comp1_post = matrix(NA, nrow=length(betaRRR), ncol=models[[4]]$ny)
for(i in 1:length(betaRRR)){
  comp1_post[i,]=models[[4]]$XRRR %*% as.matrix((wRRR_postn[i,1,]))
}

beta_comp1_post=NULL
for(i in 1:1000){
  beta_comp1_post[i]=betaRRR[i]*sd(comp1_post[i,])
}

resmat_M3[nrow(resmat_M3)+1,]=c("NA","NA","NA", 
                 round(mean(beta_comp1_post), 3),
                 round(quantile(beta_comp1_post, c(0.025)), 3),
                 round(quantile(beta_comp1_post, c(0.975)), 3),
                 "NA","NA","NA")
kable(resmat_M3)
```

#Plot selection gradients

```{r, fig.height= 5.8, fig.width= 7, echo= FALSE}
beta_fset_lap= list(resmat_RRR, resmat_M1, resmat_M2, resmat_M3)

#save(beta_fset_lap, file= "analyses/betas_fset_lap.RData")

load(file= "analyses/betas_fset_maj.RData")

mods= c("RRRco", "MR", "MRco", "RRRn")

#Variance-scaled Betas

summary_var = matrix(NA, nrow = 6, ncol = length(mods))
for(i in 1:length(mods)){
  summary_var[,i] = round(as.numeric(beta_fset_lap[[i]]$beta_var), 3)
}

colnames(summary_var) = mods
rownames(summary_var) = rownames(beta_fset_lap[[1]])
summary_var = t(summary_var)
summary_var

upper_var = matrix(NA, nrow = 6, ncol = length(mods))
for(i in 1:length(mods)){
  upper_var[,i] = round(as.numeric(beta_fset_lap[[i]]$U.1), 3)
}

colnames(upper_var) = mods
rownames(upper_var) = rownames(beta_fset_lap[[1]])
upper_var = t(upper_var)
upper_var

lower_var = matrix(NA, nrow = 6, ncol = length(mods))
for(i in 1:length(mods)){
  lower_var[,i] = round(as.numeric(beta_fset_lap[[i]]$L.1), 3)
}

colnames(lower_var) = mods
rownames(lower_var) = rownames(beta_fset_lap[[1]])
lower_var = t(lower_var)

summary_var[,6] = summary_var[,6]*-1 
lower_var[,6] = lower_var[,6]*-1
upper_var[,6] = upper_var[,6]*-1
summary_var

bdf = data.frame(summary_var, lower_var, upper_var)
names(bdf)= c("B_PlantHeight", "B_FlwSize", "B_SpurLength", "B_SpurWidth", "B_FlwOpen", "B_community", rep("Lower", times=6), rep("Upper", times=6))

bdf <- cbind(model = rownames(bdf), bdf)

bdfm= melt(setDT(bdf), measure = patterns("^B", "^Lower", "^Upper"), value.name = c("Beta_var", "Lower", "Upper"), variable.name = "trait", variable.factor = "trait")

bdf2= bdfm %>% mutate(trait= recode(trait, "1"= "Plant height", "2"= "Flower size", "3"= "Spur length", "4"= "Spur width", "5"= "Open flowers", "6"= "Community"), model= factor(model, levels= c("RRRco", "MR", "MRco", "RRRn")))

bdf2

VARplot_fset_lap= ggplot(bdf2, aes(x= model, y=Beta_var, colour=factor(model))) + 
  geom_pointrange(aes(ymin = Lower, ymax = Upper), linetype = "solid", size=0.75)+
  #geom_errorbar(aes(ymin = Lower, ymax = Upper),  width=.75)+
  labs(y= expression(beta ~ "Variance-scaled selection gradients"), x= expression(italic("Dactylorhiza lapponica"), size=12))+
  #scale_y_continuous(breaks = c(-0.50, -0.25, 0, 0.25, 0.50, 0.75), limits=c(-0.50, 1))+
  scale_y_continuous(breaks = c(-0.60, -0.40, -0.20, 0, 0.20, 0.40, 0.60, 0.80), limits=c(-0.60, 1))+
   facet_wrap(~ trait, nrow = 1L, strip.position = "top")+
  theme_bw(base_size = 15)+
  theme(text = element_text(size=15), axis.text.x= element_blank(),  axis.ticks.x = element_blank(), legend.title= element_blank(), legend.position="top",panel.grid.major.x = element_blank(), panel.grid.minor.x = element_blank(), panel.grid.major.y = element_blank(), panel.grid.minor.y = element_blank(), strip.text = element_text(size= 12))+
  geom_hline(yintercept=0, linetype="dashed", color = "black")

VARplot_fset_lap

```

```


