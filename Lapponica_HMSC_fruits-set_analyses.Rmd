---
title: "D.lapponica: Selection analyses via fruit set"
author: '"Yedra Garcia"'
date: "2023-12-06"
output: html_document
---

```{r, eval=FALSE}
library(tidyverse)
library(dplyr)
library(Hmsc)
library(abind)
library(mgcv)
library(knitr)
library(ggplot2)
library(reshape2)
library(data.table)
library(ggpubr)
library(forcats)
```


#Loading trait, fitness and co-flowering community data

```{r, eval=FALSE}

traitdata= read.csv("data/data_CRO/Gotland_trait_data.csv", header=T, sep= ";", dec=",") %>% mutate(individual= as.character(individual))%>%select(-c(18:23))#remove extra columns at the end

commudata= read.csv("data/data_CRO/Gotland_community_data.csv", header= T, sep= ";", fileEncoding="latin1")%>% mutate(individual= as.character(individual), Primula_farinosa= as.integer(factor(Primula_farinosa)))%>% select(-c(57:60))##remove extra-columns

```

#Remove unnecessary columns and rename trait variables

```{r pressure, echo=FALSE}
dat= traitdata %>% select(-c(2:5, 14))%>%
  rename(height= height_cm, flower_size= flower_size_mm, spur_length= spur_length_mm, spur_width= spur_width_mm, flowers= No_of_flowers)

```

Check for outliers

```{r, fig.width= 7, fig.height= 6, echo= F, warning= F}

par(mfrow= c(3,3))
hist(dat$height)
hist(dat$flower_size)
hist(dat$spur_length)
hist(dat$spur_width)
hist(dat$flowers_open)
hist(dat$flowers)

data= dat %>% filter(!dat$flower_size <=2)
```

Phenotypic correlation matrix
```{r, echo= F}
Plap = cor(cbind(data$height, data$flower_size, data$spur_length, data$spur_width, data$flowers_open), use="pairwise")
colnames(Plap) = rownames(Plap) = c("height", "flower_size", "spur_length", "spur_width",
                              "open flowers")
Plap
```

Summary statistics
```{r, echo= F}
summary_table= data.frame(
  variable = names(data)[sapply(data, is.numeric)],
  mean = sapply(data[, sapply(data, is.numeric)], mean, na.rm = TRUE),
  SD = sapply(data[, sapply(data, is.numeric)], sd, na.rm = TRUE)
)

print(summary_table)
```

Merge trait-fruit data with community data

```{r, echo= F, warning= F}
all_data= merge(data, commudata, by= "individual", all.x= TRUE)

```

#Abundance and prevalence of co-flowering species

```{r, fig.width= 7, fig.height= 4, echo= F}
#Abundances of the co-flowering species
sort(colSums(all_data[, 13:67]))

coflow= all_data[, 13:67]
preval= colMeans(coflow>0)
mean(preval)
abund= colSums(coflow)/colSums(coflow>0)

par(mfcol=c(1,2))
hist(preval)
hist(abund)
```

####HMSC model

To estimate the effects of co-flowering community composition on relative reproductive fitness (fruits produced) of D. lapponica, we set up a HMSC model in which we follow a reduced-rank regression approach (RRR) that reduces the number of dimensions of the animal-pollinated co-flowering species in the surrounding community and select those that best explain variation in the response (i.e., relative fruit set). In addition, we include as standard predictors in the HMSC model five phenotypic traits (plant height, flower size, spur length, spur width, number of open flowers). Thus, we also estimate the linear selection gradients for each trait while accounting for effects of the co-flowering community. 

To test the suitability of our model "m" (community model), we compare with three alternative models: 1) a model that only includes the traits as predictors "m1", 2) a model that includes the traits and each animal-pollinated co-floweing species as predictors (Opedal et al 2022. J Evol Biol) "m2", and 3) a model that includes the traits and a reduced rank regression of the non-animal pollinated co-flowering community "m3" (i.e. a natural control using plant species for which we would not expect pollinator-mediated plant-plant interactions).

```{r, echo= F}
#HMSC
indat= na.omit(all_data)##157 individuals with information on fruits produced

#Define the response variable Y
Y= cbind(indat$fruit_number)
hist(Y)
```


```{r, echo= F}
#Define XData: height, flower size, spur length, spur width, open flowers
XData= indat[, c(2,6,7,8,11)]

head(XData)
```
#Animal-pollinated co-flowering species:

```{r, echo= F}
coflo_data= indat[, 13:67]# co-flowering species

## Animal-pollinated co-flowering species

anim= c("Potentilla_erecta", "Primula_farinosa", "Pinguicula_vulgaris", "Succisa_pratensis", "Centaurea_jacea", "Prunella_grandiflora", "Prunella_vulgaris",
"Prunella_grandifloraxvulgaris", "Polygala_amarella", "Centarium_littorale", "Parnassia_palustris", "Antennaria_dioica", "Linum_catharticum", "Galium_boreale",
"Tetragonolobus_maritimus", "Scorzonera_humilis", "Tofieldia.calyculata", "Anthericum_ramosum", "Epipactis_palustris", "Platanthera_bifolia", "Gymnadenia_conopsea", "Gymnadenia_densiflora", "Gymnadenia_odoratissima", "Dactylorhiza_majalis_lapponica", "Inula.salicina", "Gentianella_uliginosa_cf", "Frangula_alnus_smallplant",
"Euphrasia_salisburgensis", "Vaccinium_vitis.idaea", "Asperula_tinctoria",
"Gymnadenia_sp", "Allium_schoenoprasum", "Leontodon_autumnalis", "Potentilla_reptans", "Calluna_vulgaris", "Dactylorhiza_incarnata_cruenta")

```

Define the XRRRData for the subset of the animal-pollinated species, and remove singletons (species only found close to one D. lapponica individual)

```{r, echo=FALSE}
XRRRData = coflo_data[, colnames(coflo_data) %in% anim]

XRRRData = XRRRData[, match(anim, colnames(XRRRData))]
head(XRRRData)

sort(colSums(XRRRData))

XRRRData = XRRRData[, colSums(XRRRData>=1) >1]
length(XRRRData)#28 species in more than one sampling unit
```

Define the Xformula with the trait predictors (= XData)

```{r}
XFormula = as.formula(paste("~", paste0(colnames(XData), collapse=" + ")))
XFormula

```

Define the XRRRformula with the animal-pollinated species (= XRRRData)

```{r}
XRRRFormula = as.formula(paste("~", " -1 + ", paste0(colnames(XRRRData), collapse=" + ")))
XRRRFormula
```

Scale the XRRRData (the animal-pollinated co-flowering species)

```{r}
XRRRDataScaled = data.frame(scale(XRRRData))
dim(XRRRData)
```

#1.2 Fit the HMSC models.

#HMSC model with traits and the RRR of the animal-pollinated species as predictors (m)

```{r}

m = Hmsc(Y = as.matrix(Y/mean(Y)), XData=XData, XFormula=XFormula,
         distr="normal", 
         XRRRData=XRRRDataScaled, XRRRFormula=XRRRFormula, ncRRR=1, XRRRScale = TRUE)
```

#Alternative models:

#HMSC only with traits as predictors (m1)

```{r}
m1 = Hmsc(Y = as.matrix(Y/mean(Y)), XData=XData, XFormula=XFormula,
          distr="normal")
```

#HMSC with traits and each animal-pollinated species as predictors (m2)

Here, we need another XData object (= XData2) that includes the traits and each animal-poll co-flowering species (XRRRData) and define an Xformula for it (= XFormula2)

```{r}
XData2 = data.frame(XData, XRRRData)
XFormula2 = as.formula(paste("~", paste0(colnames(XData2), collapse=" + ")))
XFormula2

m2 = Hmsc(Y = as.matrix(Y/mean(Y)), XData=XData2, XFormula=XFormula2,
          distr="normal")
```

#HMSC with traits and the RRR of the non-animal pollinated species as predictors (m3)

Here, we need another XRRRData object (= XRRRData2) for the non-animal pollinated species. As we did before, we remove singletons and scale the XRRRRData2 object.

Then we define the XRRRformula (XRRRFormula2)

```{r}
XRRRData2= coflo_data[!(colnames(coflo_data) %in% anim)]

XRRRData2 = XRRRData2[, colSums(XRRRData2>=1) >1]

XRRRDataScaled2 = data.frame(scale(XRRRData2))
dim(XRRRData2)

XRRRFormula2 = as.formula(paste("~", " -1 + ", paste0(colnames(XRRRData2), collapse=" + ")))

XRRRFormula2

m3 = Hmsc(Y = as.matrix(Y/mean(Y)), XData=XData, XFormula=XFormula,
         distr="normal", XRRRData= XRRRDataScaled2, XRRRFormula=XRRRFormula2, ncRRR=1, XRRRScale = TRUE)
```

Now we set the sampling parameters and fit the four models.

```{r, echo=FALSE}
samples = 1000
thin = 100
transient = .5*(thin*samples)
adaptNf = 0.4*(thin*samples)
nChains = 1

models= list(m, m1, m2, m3)
for(i in 1:4){
  models[[i]]= sampleMcmc(models[[i]], samples = samples, thin = thin, adaptNf=rep(adaptNf, m$nr), 
               transient = transient, nChains = nChains)}

#save(models, file ="analyses/models_fset_lap.RData")

load(file ="analyses/models_fset_lap.RData")
```

##Check effective sample sizes

```{r, echo=FALSE}

post= convertToCodaObject(models[[1]], covNamesNumbers = c(T,F))
post1= convertToCodaObject(models[[2]], covNamesNumbers = c(T,F))
post2= convertToCodaObject(models[[3]], covNamesNumbers = c(T,F))
post3= convertToCodaObject(models[[4]], covNamesNumbers = c(T,F))

effectiveSize(post$Beta)

```

#Asess MCMC convergence and get posterior support for each model parameter including the co-flowering community axis (model "m")

```{r}
#Posterior support for the RRR animal-pollinated co-flowering community
getPostEstimate(models[[1]], "Beta")

postsup= getPostEstimate(models[[1]], "Beta")$support[2:7, ]

postsup[which(postsup<0.5)] = 1 - postsup[which(postsup<0.5)]
postsup
```

MCMC convergence

```{r}
plot(post$Beta[,1:7])
```

```{r}
# Temp. posterior of wRRR# the animal-pollinated co-flowering species
bind0 = function(...) {abind(..., along = 0)}
postList = poolMcmcChains(models[[1]]$postList, chainIndex = 1:length(models[[1]]$postList), 
                          start = 1, thin = 1)
valList = lapply(postList, function(a) a[["wRRR"]])
wRRR_post = do.call(bind0, valList)

dim(wRRR_post)

for(i in 1:28){
  plot(wRRR_post[,1,i], type="l")
}

```

#Model fitting

Now we evaluate the explanatory power of the model "m" by computing the R\^2 values and compare with alternative models (m1, m2 and m3)

```{r}

MF_results= matrix(NA, nrow= 2, ncol= 4)
for(i in 1:4){
  m= models[[i]]
  pred= computePredictedValues(m)
        MF= evaluateModelFit(hM= m, predY = pred)
        MF_results[1,i]= mean(MF$R2)
}

MF_results
```

Now we evaluate the predictive power of the model "m" and of the alternative models by using 5-fold cross validation

```{r}
partition= createPartition(m, nfolds=5)

for(i in 1:4){
  m= models[[i]]
  pred_CV = computePredictedValues(m, partition)
  MF_CV= evaluateModelFit(hM= m, predY = pred_CV)
  MF_results[2, i]= mean(MF_CV$R2)
}

MF_results

colnames(MF_results)= c("RRRco", "MR", "MRco", "RRRn")
rownames(MF_results)=  c("MF", "MF_cV")

MF_results= as.data.frame(MF_results)

#save(MF_results, file="results/MF_fset_lap.RData")

MF_results#Table 1
```
Next thing we will do is to estimate the partial regression coefficients for each trait, which correspond to the linear selection gradients through reproductive success, and for the co-flowering community axis.

#Obtain linear selection gradients for model "m" (includes traits and the RRR of the co-flowering community)

```{r}
nX = ncol(models[[1]]$XData)
nX

#beta_raw_post = post$Beta[,2:(nX+1)][[1]] #posterior for betas
beta_raw_post = post$Beta[,2:(5+1)][[1]]

beta_var_post = matrix(NA, nrow=nrow(beta_raw_post), ncol=nX)
for(i in 1:nX){
  beta_var_post[,i] = beta_raw_post[,i]*sd(XData[,i])
}

beta_mean_post = matrix(NA, nrow=nrow(beta_raw_post), ncol=nX)
for(i in 1:nX){
  beta_mean_post[,i] = beta_raw_post[,i]*mean(XData[,i])
}

beta_raw = apply(beta_raw_post, 2, mean)
beta_raw_lower = apply(beta_raw_post, 2, quantile, c(0.025))
beta_raw_upper = apply(beta_raw_post, 2, quantile, c(0.975))

#Variance-scaled betas
beta_var = apply(beta_var_post, 2, mean)
beta_var_lower = apply(beta_var_post, 2, quantile, c(0.025))
beta_var_upper = apply(beta_var_post, 2, quantile, c(0.975))

#Mean-scaled betas (this only applies to mean-scaled selection gradients, as the community axis is not on a ratio scale, and thus mean-scale is not meaningful)
beta_mean = apply(beta_mean_post, 2, mean)
beta_mean_lower = apply(beta_mean_post, 2, quantile, c(0.025))
beta_mean_upper = apply(beta_mean_post, 2, quantile, c(0.975))

resmat_RRR = data.frame(beta_raw = round(beta_raw, 3),
                        L = round(beta_raw_lower, 3),
                        U = round(beta_raw_upper, 3),
                        beta_var = round(beta_var, 3),
                        L = round(beta_var_lower, 3),
                        U = round(beta_var_upper, 3),
                        beta_mean = round(beta_mean*100, 3),
                        L = round(beta_mean_lower, 3),
                        U = round(beta_mean_upper, 3))

betaRRR = post$Beta[,(nX+2):(models[[1]]$ncRRR+(nX+1))][[1]] #posterior for beta_RRR
#betaRRR = post$Beta[,(5+2):(m$ncRRR+(5+1))][[1]] #posterior for beta_RRR
length(betaRRR)

# Adding the regression coefficient (B) for the animal-pollinated community axis"
#For the community axis, only variance-scaled B is reported (is not on a ratio scale, mean-scaled not meaningful).

# The anim-pollinated co-flowering community axis"
dim(models[[1]]$XRRR)

comp1_post = matrix(NA, nrow=length(betaRRR), ncol=models[[1]]$ny)
for(i in 1:length(betaRRR)){
  comp1_post[i,]=models[[1]]$XRRR %*% as.matrix((wRRR_post[i,1,]))
}

beta_comp1_post=NULL
for(i in 1:1000){
  beta_comp1_post[i]=betaRRR[i]*sd(comp1_post[i,])
}

resmat_RRR[nrow(resmat_RRR)+1,]=c("NA","NA","NA", 
                 round(mean(beta_comp1_post), 3),
                 round(quantile(beta_comp1_post, c(0.025)), 3),
                 round(quantile(beta_comp1_post, c(0.975)), 3),
                 "NA","NA","NA")
kable(resmat_RRR) #The sign of the regression coefficient for the RRR on the community axis is arbitrary, here
#negative (-0.13), so we multiply it by -1 for the sake of interpretation
```


# Calculating the corresponding slopes for the original variables (co-flowering species) 
```{r, echo=FALSE}
betapost = post$Beta[,5:(models[[1]]$ncRRR+4)][[1]] #posterior for beta_RRR


beta_raw_post = matrix(NA, nrow=length(betapost), ncol=models[[1]]$ncORRR)
for(i in 1:length(betapost)){
  beta_raw_post[i,] = t(as.matrix(wRRR_post[i,,])) * betapost[i] #Need matrix * for more than one RRR
}

beta_var_post = matrix(NA, nrow=length(betapost), ncol=models[[1]]$ncORRR)
for(i in 1:models[[1]]$ncORRR){
  beta_var_post[,i] = beta_raw_post[,i]*sd(models[[1]]$XRRRData[,i])
}

# Compute beta = wA for each posterior sample

# Alternative if XRRRData scaled before model fitting

beta_mean_post = matrix(NA, nrow=length(betapost), ncol=models[[1]]$ncORRR)
for(i in 1:models[[1]]$ncORRR){
  beta_mean_post[,i] = beta_raw_post[,i]*(mean(XRRRData[,i])/sd(XRRRData[,i]))
}

beta_raw = apply(beta_raw_post, 2, mean)
beta_raw_lower = apply(beta_raw_post, 2, quantile, c(0.025))
beta_raw_upper = apply(beta_raw_post, 2, quantile, c(0.975))

beta_var = apply(beta_var_post, 2, mean)
beta_var_lower = apply(beta_var_post, 2, quantile, c(0.025))
beta_var_upper = apply(beta_var_post, 2, quantile, c(0.975))

beta_mean = apply(beta_mean_post, 2, mean)
beta_mean_lower = apply(beta_mean_post, 2, quantile, c(0.025))
beta_mean_upper = apply(beta_mean_post, 2, quantile, c(0.975))

betamat_RRR = data.frame(beta_raw = round(beta_raw, 3),
                         lower = round(beta_raw_lower, 3),
                         upper = round(beta_raw_upper, 3),
                         beta_var = round(beta_var, 3),
                         lower = round(beta_var_lower, 3),
                         upper = round(beta_var_upper, 3),
                         beta_mean = round(beta_mean*100, 3),
                         L = round(beta_mean_lower*100, 3),
                         U = round(beta_mean_upper*100, 3))
rownames(betamat_RRR) = colnames(models[[1]]$XRRRData)

betamat_RRR
```


```{r, echo=FALSE}
betamat_plot= betamat_RRR
betamat_plot$species= rownames(betamat_RRR)

str(betamat_plot)

ggplot(betamat_plot, aes(x = reorder(species, beta_var), y = beta_var)) +
  geom_point() +
  geom_errorbar(aes(ymin = lower.1, ymax = upper.1), width = 0.2) +
  coord_flip() +
  labs(x = "Co-flowering species", y = "Variance-scaled B",
       title = "Slopes for original variables (co-flowering species)") +
  theme_minimal()

```

#Co-flowering species weights: contribution of each animal-pollinated co-flowering species to the composite community axis
```{r, echo=FALSE}
par(mar = c(4, 12, 2, 2), xpd = TRUE)

wRRR = getPostEstimate(models[[1]], "wRRR")

#Because the sign of the regression coefficient (Beta) for the community axis was negative (and we multiplied it by -1 for the sake of interpretation), we also need to flip the wRRR to visualize the species weights correctly.
ord= order(-wRRR$mean, decreasing = FALSE)

out= barplot(-wRRR$mean[ord],
               horiz = TRUE,
               col = "darkgrey",
               xlim = c(-1, 2),
               las = 1,
               xlab = "Co-flowering species weights")

species_labels= gsub("_", " ", colnames(XRRRData)[ord])

species_expr= parse(text = paste0("italic('", species_labels, "')"))

text(x = -1.5, y = out,
     labels = species_expr,
     adj = 1, cex = 0.6)
```

#Selection gradients for model "m1" (only phenotypic traits)

```{r, echo=FALSE}
nX = ncol(models[[2]]$XData)
nX

#beta_raw_post = post$Beta[,2:(nX+1)][[1]] #posterior for betas
beta_raw_post = post1$Beta[,2:(5+1)][[1]]

head(beta_raw_post)

beta_var_post = matrix(NA, nrow=nrow(beta_raw_post), ncol=nX)
for(i in 1:nX){
  beta_var_post[,i] = beta_raw_post[,i]*sd(XData[,i])
}

beta_mean_post = matrix(NA, nrow=nrow(beta_raw_post), ncol=nX)
for(i in 1:nX){
  beta_mean_post[,i] = beta_raw_post[,i]*mean(XData[,i])
}

beta_raw = apply(beta_raw_post, 2, mean)
beta_raw_lower = apply(beta_raw_post, 2, quantile, c(0.025))
beta_raw_upper = apply(beta_raw_post, 2, quantile, c(0.975))

beta_var = apply(beta_var_post, 2, mean)
beta_var_lower = apply(beta_var_post, 2, quantile, c(0.025))
beta_var_upper = apply(beta_var_post, 2, quantile, c(0.975))

beta_mean = apply(beta_mean_post, 2, mean)
beta_mean_lower = apply(beta_mean_post, 2, quantile, c(0.025))
beta_mean_upper = apply(beta_mean_post, 2, quantile, c(0.975))


resmat_M1 = data.frame(beta_raw = round(beta_raw, 3),
                        L = round(beta_raw_lower, 3),
                        U = round(beta_raw_upper, 3),
                        beta_var = round(beta_var, 3),
                        L = round(beta_var_lower, 3),
                        U = round(beta_var_upper, 3),
                        beta_mean = round(beta_mean*100, 3),
                        L = round(beta_mean_lower, 3),
                        U = round(beta_mean_upper, 3))

resmat_M1[nrow(resmat_M1)+1,]= rep(c("NA"), times= 9)


kable(resmat_M1)
```

#Selection gradients for model "m2" (phenotypic traits and each co-flowering animal-poll species as
#standard covariates)
```{r, echo=FALSE}

nX = ncol(models[[3]]$XData)
nX

beta_raw_post = post2$Beta[,2:(5+1)][[1]] #posterior for betas
#beta_raw_post = post2$Beta[,2:(33+1)][[1]] 
head(beta_raw_post)


beta_var_post = matrix(NA, nrow=nrow(beta_raw_post), ncol=ncol(beta_raw_post))
  for(i in 1:ncol(beta_raw_post)){
    beta_var_post[,i] = beta_raw_post[,i]*sd(models[[3]]$XData[,i])
  }
  
  beta_mean_post = matrix(NA, nrow=nrow(beta_raw_post), ncol=ncol(beta_raw_post))
  for(i in 1:ncol(beta_raw_post)){
    beta_mean_post[,i] = beta_raw_post[,i]*mean(models[[3]]$XData[,i])
  }

beta_raw = apply(beta_raw_post, 2, mean)
beta_raw_lower = apply(beta_raw_post, 2, quantile, c(0.025))
beta_raw_upper = apply(beta_raw_post, 2, quantile, c(0.975))

beta_var = apply(beta_var_post, 2, mean)
beta_var_lower = apply(beta_var_post, 2, quantile, c(0.025))
beta_var_upper = apply(beta_var_post, 2, quantile, c(0.975))

beta_mean = apply(beta_mean_post, 2, mean)
beta_mean_lower = apply(beta_mean_post, 2, quantile, c(0.025))
beta_mean_upper = apply(beta_mean_post, 2, quantile, c(0.975))


resmat_M2 = data.frame(beta_raw = round(beta_raw, 3),
                        L = round(beta_raw_lower, 3),
                        U = round(beta_raw_upper, 3),
                        beta_var = round(beta_var, 3),
                        L = round(beta_var_lower, 3),
                        U = round(beta_var_upper, 3),
                        beta_mean = round(beta_mean*100, 3),
                        L = round(beta_mean_lower, 3),
                        U = round(beta_mean_upper, 3))
resmat_M2[nrow(resmat_M2[,])+1,]= rep(c("NA"), times= 9)

kable(resmat_M2)

```
#Selection gradients for model "m4" that includes phenotypic traits and the RRR of non-animal-pollinated species in the community

```{r}
nX = ncol(models[[4]]$XData)
nX

#beta_raw_post = post$Beta[,2:(nX+1)][[1]] #posterior for betas
beta_raw_post = post3$Beta[,2:(5+1)][[1]]
head(beta_raw_post)

beta_var_post = matrix(NA, nrow=nrow(beta_raw_post), ncol=nX)
for(i in 1:nX){
  beta_var_post[,i] = beta_raw_post[,i]*sd(XData[,i])
}

beta_mean_post = matrix(NA, nrow=nrow(beta_raw_post), ncol=nX)
for(i in 1:nX){
  beta_mean_post[,i] = beta_raw_post[,i]*mean(XData[,i])
}

beta_raw = apply(beta_raw_post, 2, mean)
beta_raw_lower = apply(beta_raw_post, 2, quantile, c(0.025))
beta_raw_upper = apply(beta_raw_post, 2, quantile, c(0.975))

beta_var = apply(beta_var_post, 2, mean)
beta_var_lower = apply(beta_var_post, 2, quantile, c(0.025))
beta_var_upper = apply(beta_var_post, 2, quantile, c(0.975))

beta_mean = apply(beta_mean_post, 2, mean)
beta_mean_lower = apply(beta_mean_post, 2, quantile, c(0.025))
beta_mean_upper = apply(beta_mean_post, 2, quantile, c(0.975))

resmat_M3 = data.frame(beta_raw = round(beta_raw, 3),
                        L = round(beta_raw_lower, 3),
                        U = round(beta_raw_upper, 3),
                        beta_var = round(beta_var, 3),
                        L = round(beta_var_lower, 3),
                        U = round(beta_var_upper, 3),
                        beta_mean = round(beta_mean*100, 3),
                        L = round(beta_mean_lower, 3),
                        U = round(beta_mean_upper, 3))
#resmat_M3[nrow(resmat_M3[,])+1,]= rep(c("NA"), times= 9)

#####
betaRRR = post3$Beta[,(nX+2):(models[[4]]$ncRRR+(nX+1))][[1]] #posterior for beta_RRR
#betaRRR = post$Beta[,(5+2):(m$ncRRR+(5+1))][[1]] #posterior for beta_RRR
length(betaRRR)

# The non-anim-pollinated co-flowering community axis"
dim(models[[4]]$XRRR)

# Temp. posterior of wRRR
bind0 = function(...) {abind(..., along = 0)}
postList = poolMcmcChains(models[[4]]$postList, chainIndex = 1:length(models[[4]]$postList), 
                          start = 1, thin = 1)
valList = lapply(postList, function(a) a[["wRRR"]])
wRRR_postn = do.call(bind0, valList)

comp1_post = matrix(NA, nrow=length(betaRRR), ncol=models[[4]]$ny)
for(i in 1:length(betaRRR)){
  comp1_post[i,]=models[[4]]$XRRR %*% as.matrix((wRRR_postn[i,1,]))
}

beta_comp1_post=NULL
for(i in 1:1000){
  beta_comp1_post[i]=betaRRR[i]*sd(comp1_post[i,])
}

resmat_M3[nrow(resmat_M3)+1,]=c("NA","NA","NA", 
                 round(mean(beta_comp1_post), 3),
                 round(quantile(beta_comp1_post, c(0.025)), 3),
                 round(quantile(beta_comp1_post, c(0.975)), 3),
                 "NA","NA","NA")
kable(resmat_M3)#here again the sign of the effects of the non-animal-pollinated community is negative, so we multiply by -1 for the sake of interpretation
```

#Save betas from each model (Tables 1, 3, S4 and Fig 2)

```{r}

beta_fset_lap= list(resmat_RRR, resmat_M1, resmat_M2, resmat_M3)

#save(beta_pol_lap, file="analyses/betas_fset_lap.RData")

load(file= "analyses/betas_fset_lap.RData")

```

#Save data from model "m" to use in post-hoc models

```{r}
Xmat= as.matrix(models[[1]]$XData)    
Yvec= as.numeric(models[[1]]$Y)  

# Center and scale traits
Xc= scale(Xmat, center = TRUE, scale = TRUE)
traits_names= colnames(Xc)

all_models.flap= list()

for(i in seq_along(models)) {
  m= models[[i]]
  
  # Check if model has RRR and it is not NULL
  if("XRRRData" %in% names(m) && !is.null(m$XRRRData)) {
    XRRRmat= scale(as.matrix(m$XRRRData), center = TRUE, scale = TRUE)
    hasRRR= TRUE
  } else {
    XRRRmat= NA
    hasRRR= FALSE
  }
  
  # Store 
  all_models.flap[[i]]= list(
    mcmc = m,
    XData = Xmat,              
    XRRRDataScaled = XRRRmat,
    Y = Yvec,                   
    hasRRR = hasRRR
  )
}

#saveRDS(all_models.flap, "analyses/models.fset_lap_fulldata.rds")

```

#Testing for an interaction between co-flowering community axis (model "m") and selection on traits (Table S6)

#Run a post-hoc model over the posterior samples (1000) of the community axis from the HMSC model "m" and traits

```{r}
all_models.flap= readRDS("analyses/models.fset_lap_fulldata.rds")

model= all_models.flap[[1]]

# Ensure model has RRR
if(!model$hasRRR) stop("This model has no RRR data!")

XRRRmat= as.matrix(model$XRRRDataScaled) #co-flowering species
Xmat= as.matrix(model$XData) #phenotypic traits
traits_names= make.names(colnames(Xmat))
Y= as.numeric(model$Y) #response variable (reproductive fitness)
Xc= scale(Xmat)

#Pool posterior chains and extract co-flowering species (RRR) weights
postList= poolMcmcChains(model$mcmc$postList,
                           chainIndex = 1:length(model$mcmc$postList),
                           start = 1, thin = 1)

bind0= function(...) abind(..., along = 0)
valList= lapply(postList, function(a) a[["wRRR"]])
wRRR_post= do.call(bind0, valList)
nSamples= dim(wRRR_post)[1]

# Compute RRR axes for each posterior sample (one axis per posterior sample)
nInd= nrow(XRRRmat)
rrr_post_flap= matrix(NA, nrow = nInd, ncol = nSamples)

for(s in seq_len(nSamples)){
  w_vec= wRRR_post[s, 1, ]
  if(is.null(w_vec)) next
  rrr_post_flap[, s]= XRRRmat %*% as.numeric(w_vec)
}

#Matrix to store coefficients
coef_names= c("(Intercept)", paste0("trait_", traits_names), "axis", paste0("int_", traits_names))
coef_store= matrix(NA, nrow = nSamples, ncol = length(coef_names), dimnames = list(NULL, coef_names))

# Fit regression for each posterior sample
for(s in seq_len(nSamples)){
  axis_s= rrr_post_flap[, s]
  if(all(is.na(axis_s))) next
  axis_s_c= as.numeric(scale(axis_s))

  df= data.frame(Y = Y, axis = axis_s_c, Xc)
  
  for(tr in traits_names){
    df[[paste0("I_", tr, "_axis")]] <- df[[tr]] * df$axis
  }

  main_terms= paste(traits_names, collapse = " + ")
  inter_terms= paste(paste0("I_", traits_names, "_axis"), collapse = " + ")
  form= as.formula(paste0("Y ~ ", main_terms, " + axis + ", inter_terms))

  fit= tryCatch(lm(form, data = df), error = function(e) NULL)
  if(is.null(fit)) next
  
  coefs= coef(fit)
  coef_store[s, "(Intercept)"]= if(!is.null(coefs["(Intercept)"])) coefs["(Intercept)"] else NA
  coef_store[s, "axis"]= if(!is.null(coefs["axis"])) coefs["axis"] else NA

  for(tr in traits_names){
    trait_name= paste0("trait_", tr)
    int_name= paste0("int_", tr)
    inter_term= paste0("I_", tr, "_axis")
    coef_store[s, trait_name]= if(!is.null(coefs[tr])) coefs[tr] else NA
    coef_store[s, int_name]= if(!is.null(coefs[inter_term])) coefs[inter_term] else NA
  }
}

# Summarize posterior distribution of regression coefficients
#mean, median, credible intervals and posterior support
summ= data.frame(
  term = coef_names,
  mean = apply(coef_store, 2, mean, na.rm = TRUE),
  median = apply(coef_store, 2, median, na.rm = TRUE),
  ci_lower = apply(coef_store, 2, quantile, probs = 0.025, na.rm = TRUE),
  ci_upper = apply(coef_store, 2, quantile, probs = 0.975, na.rm = TRUE),
  p_pos = apply(coef_store, 2, function(x) mean(x > 0, na.rm = TRUE)),
  p_neg = apply(coef_store, 2, function(x) mean(x < 0, na.rm = TRUE)),
  stringsAsFactors = FALSE
)

summ$postsup= apply(coef_store, 2, function(x){
  ps= mean(x > 0, na.rm = TRUE)
  if(is.na(ps)) return(NA_real_)
  if(ps < 0.5) ps <- 1 - ps
  return(ps)
})

print(summ)#Table S6

```

#Figure 4a: fitness surface, interaction between co-flowering community axis and selection on floral display

```{r flap, fig.width=6, fig.height=6, dpi=300}

svg("plots/fitlap.svg", height=6, width=6)

cols= colorRampPalette(c("dodgerblue", "white", "deeppink"))(100)

trait= "flowers_open"              
model= all_models.flap[[1]] 

Xmat= as.matrix(model$XData)
Y= as.numeric(model$Y)

#Scale traits
Xc= scale(Xmat, center = TRUE, scale = TRUE)
trait_mean= attr(Xc, "scaled:center")[trait]
trait_sd= attr(Xc, "scaled:scale")[trait]

#Community axis (from RRR posterior)
axis_values= rowMeans(rrr_post_flap, na.rm = TRUE)
axis_mean= mean(axis_values)
axis_sd= sd(axis_values)

#Grid for surface (raw values)
trait_seq= seq(min(Xmat[, trait], na.rm = TRUE),
                 max(Xmat[, trait], na.rm = TRUE), length.out = 50)
axis_seq= seq(min(axis_values, na.rm = TRUE),
                max(axis_values, na.rm = TRUE), length.out = 50)
grid= expand.grid(trait_val = trait_seq, axis_val = axis_seq)

#Scale grid
grid$trait_scaled= (grid$trait_val - trait_mean) / trait_sd
grid$axis_scaled= (grid$axis_val - axis_mean) / axis_sd

#Predicted fitness surface
coef_mean= colMeans(coef_store, na.rm = TRUE)
grid$fit= with(grid,
                 coef_mean["(Intercept)"] +
                 coef_mean[paste0("trait_", trait)] * trait_scaled +
                 coef_mean["axis"] * axis_scaled +
                 coef_mean[paste0("int_", trait)] * trait_scaled * axis_scaled)

zmat= matrix(grid$fit, nrow = length(trait_seq), ncol = length(axis_seq))

#Map z values to colors
z_range= range(zmat, na.rm = TRUE)
z_scaled= round((zmat - z_range[1]) / diff(z_range) * 99) + 1
surface_colors= cols[z_scaled]

#Plot surface
pmat= persp(trait_seq, axis_seq, zmat,
              theta = 120, phi = 30, expand = 0.6,
              col = surface_colors,
              border = "grey90",      
              ticktype = "detailed",
              xlab = ifelse(trait=="flowers_open","Flowers open"),
              ylab = "Community axis",
              zlab = "Relative fitness")

#Observed data points (raw units)
ok= complete.cases(Xmat[, trait], axis_values, Y)
x_obs= Xmat[ok, trait]
y_obs= axis_values[ok]
z_obs= Y[ok]

#Predicted z for each observation (posterior mean model)
z_pred= with(data.frame(
  trait_scaled = (x_obs - trait_mean) / trait_sd,
  axis_scaled  = (y_obs - axis_mean) / axis_sd
), coef_mean["(Intercept)"] +
   coef_mean[paste0("trait_", trait)] * trait_scaled +
   coef_mean["axis"] * axis_scaled +
   coef_mean[paste0("int_", trait)] * trait_scaled * axis_scaled)

#Project to 2D plane for plotting
pp_obs= trans3d(x_obs, y_obs, z_obs, pmat)
pp_pred= trans3d(x_obs, y_obs, z_pred, pmat)

#Draw vertical connectors (residual variation)
segments(pp_obs$x, pp_obs$y, pp_pred$x, pp_pred$y,
         col = rgb(0.3, 0.3, 0.3, 0.3), lwd = 1)

#Overlay observed points
points(pp_obs, col = rgb(0,0,0,0.7), pch = 16, cex = 0.6)

dev.off()

```

#Testing for realized environmental correlations: Table S5

#We use the RRR community axis derived from our main model "m" and calculate its correlation with phenotypic traits
```{r, echo=FALSE}
wRRR = getPostEstimate(models[[1]], "wRRR")

rrr = as.matrix(models[[1]]$XRRRData) %*% t(as.matrix(wRRR$mean))# the community axis

names(models[[1]]$XData)#the phenotypic traits

cor.flap = cor(rrr[,1], models[[1]]$XData)
cor.flap

```



```{r, fig.height= 5.8, fig.width= 7, echo= FALSE}
beta_fset_lap= list(resmat_RRR, resmat_M1, resmat_M2, resmat_M3)

beta_fset_lap

#save(beta_fset_lap, file= "analyses/betas_fset_lap.RData")

load(file= "analyses/betas_fset_lap.RData")

mods= c("RRRco", "MR", "MRco", "RRRn")

#Variance-scaled Betas

summary_var = matrix(NA, nrow = 6, ncol = length(mods))
for(i in 1:length(mods)){
  summary_var[,i] = round(as.numeric(beta_fset_lap[[i]]$beta_var), 3)
}


summary_var
colnames(summary_var) = mods
rownames(summary_var) = rownames(beta_fset_lap[[1]])
summary_var = t(summary_var)
summary_var

upper_var = matrix(NA, nrow = 6, ncol = length(mods))
for(i in 1:length(mods)){
  upper_var[,i] = round(as.numeric(beta_fset_lap[[i]]$U.1), 3)
}

colnames(upper_var) = mods
rownames(upper_var) = rownames(beta_fset_lap[[1]])
upper_var = t(upper_var)
upper_var

lower_var = matrix(NA, nrow = 6, ncol = length(mods))
for(i in 1:length(mods)){
  lower_var[,i] = round(as.numeric(beta_fset_lap[[i]]$L.1), 3)
}

colnames(lower_var) = mods
rownames(lower_var) = rownames(beta_fset_lap[[1]])
lower_var = t(lower_var)

summary_var[,6] = summary_var[,6]*-1 
lower_var[,6] = lower_var[,6]*-1
upper_var[,6] = upper_var[,6]*-1
summary_var

bdf = data.frame(summary_var, lower_var, upper_var)
names(bdf)= c("B_PlantHeight", "B_FlwSize", "B_SpurLength", "B_SpurWidth", "B_FlwOpen", "B_community", rep("Lower", times=6), rep("Upper", times=6))

bdf <- cbind(model = rownames(bdf), bdf)
library(reshape2)
library(data.table)
head(bdf)

bdfm= melt(setDT(bdf), measure = patterns("^B", "^Lower", "^Upper"), value.name = c("Beta_var", "Lower", "Upper"), variable.name = "trait", variable.factor = "trait")

head(bdfm)
```


```{r, fig.height= 5.8, fig.width= 7, echo= FALSE}
bdf2= bdfm %>% mutate(trait= recode(trait, "1"= "Plant height", "2"= "Flower size", "3"= "Spur length", "4"= "Spur width", "5"= "Open flowers", "6"= "Community"), model= factor(model, levels= c("RRRco", "MR", "MRco", "RRRn")))

bdf.lap= bdfm %>% mutate(trait= recode(trait, "1"= "Plant height", "2"= "Flower size", "3"= "Spur length", "4"= "Spur width", "5"= "Open flowers", "6"= "Community"), model= factor(model, levels= c("RRRco", "MR", "MRco", "RRRn")))


bdf.lap
```


```{r, fig.height= 5.8, fig.width= 7, echo= FALSE}
VARplot_fset_lap= ggplot(bdf2, aes(x= model, y=Beta_var, colour=factor(model))) + 
  geom_pointrange(aes(ymin = Lower, ymax = Upper), linetype = "solid", size=0.75)+
  #geom_errorbar(aes(ymin = Lower, ymax = Upper),  width=.75)+
  labs(y= expression(beta ~ "variance-scaled coefficients"), x= expression(italic("Dactylorhiza lapponica"), size=12))+
  #scale_y_continuous(breaks = c(-0.50, -0.25, 0, 0.25, 0.50, 0.75), limits=c(-0.50, 1))+
  scale_y_continuous(breaks = c(-0.60, -0.40, -0.20, 0, 0.20, 0.40, 0.60, 0.80), limits=c(-0.60, 1))+
   facet_wrap(~ trait, nrow = 1L, strip.position = "top")+
  theme_bw(base_size = 15)+
  theme(text = element_text(size=15), axis.text.x= element_blank(),  axis.ticks.x = element_blank(), legend.title= element_blank(), legend.position="top",panel.grid.major.x = element_blank(), panel.grid.minor.x = element_blank(), panel.grid.major.y = element_blank(), panel.grid.minor.y = element_blank(), strip.text = element_text(size= 12))+
  geom_hline(yintercept=0, linetype="dashed", color = "black")

VARplot_fset_lap

```


```{r}

par(mfrow = c(1, 2),    # two panels side by side
    mar = c(4, 8, 2, 2), 
    xpd = TRUE)

### --- Panel A: Focal species 1 (F. maj) ---
#model1 <- models[[1]]
wRRR1  <- getPostEstimate(model1, "wRRR")

ord1 <- order(-wRRR1$mean, decreasing = FALSE)
species_labels1 <- gsub("_", " ", colnames(model1$XRRRData)[ord1])
species_expr1   <- parse(text = paste0("italic('", species_labels1, "')"))

barplot(-wRRR1$mean[ord1],
        horiz = TRUE, 
        col = "darkgrey",
        xlim = c(-1, 2),     # <-- same scale for both panels
        las = 1, 
        main = expression(italic("F. maj")),
        xlab = "Co-flowering species weights")
text(x = -1.5, y = seq_along(ord1),
     labels = species_expr1, adj = 1, cex = 0.6)

### --- Panel B: Focal species 2 (F. lap) ---
#model2 <- models[[1]]
wRRR2  <- getPostEstimate(model2, "wRRR")

ord2 <- order(-wRRR2$mean, decreasing = FALSE)
species_labels2 <- gsub("_", " ", colnames(model2$XRRRData)[ord2])
species_expr2   <- parse(text = paste0("italic('", species_labels2, "')"))

barplot(-wRRR2$mean[ord2],
        horiz = TRUE, 
        col = "darkgrey",
        xlim = c(-1, 2),     # <-- same x-scale for visual comparability
        las = 1, 
        main = expression(italic("F. lap")),
        xlab = "Co-flowering species weights")
text(x = -1.5, y = seq_along(ord2),
     labels = species_expr2, adj = 1, cex = 0.6)


```


