---
title: 'D.lapponica: Selection analyses via pollination success'
author: '"Yedra Garcia"'
date: "2023-12-07"
output: html_document
---

```{r, eval=FALSE}
library(tidyverse)
library(dplyr)
library(Hmsc)
library(abind)
library(mgcv)
library(knitr)
library(ggplot2)
library(reshape2)
library(data.table)
library(ggpubr)
```

#Loading trait, fitness, co-flowering community and animal-poll species data
```{r, eval=FALSE}
traitdata= read.csv("data/data_CRO/Gotland_trait_data.csv", header=T, sep= ";", dec=",") %>% mutate(individual= as.character(individual))

fitdata= read.csv("data/data_CRO/Gotland_fitness_data.csv", header=T, sep= ";",) %>% mutate(individual= as.character(individual))#, pollinaria_removed=as.numeric(pollinaria_removed, na.rm = T))

commudata= read.csv("data/data_CRO/Gotland_community_data.csv", header= T, sep= ";", fileEncoding="latin1")%>% mutate(individual= as.character(individual), Primula_farinosa= as.integer(factor(Primula_farinosa)))%>% dplyr::select(-c(57:60))##because 4 empty extra-columns at #the end
```

#Remove unnecessary columns and rename trait variables from trait data
```{r, eval=FALSE}
traitdata_clean= traitdata %>% select(-c(2:5, 13, 14, 18:23))%>% 
  rename(height= height_cm, flower_size= flower_size_mm, spur_length= spur_length_mm, spur_width= spur_width_mm,
         flowers= No_of_flowers)
```

#Estimate visitation at flower level
```{r, eval=FALSE}
fitdata = na.omit(fitdata)

fitdata= fitdata %>% mutate(pollinaria_removed= as.numeric(pollinaria_removed))

fitdata= fitdata%>% mutate(fvisit= 1*((pollen_on_stigma+ pollinaria_removed)>0))#Flower
#pollinated when it has at least presence of pollen on stigma or one pollinaria removed
```

#Estimate pollination success at the individual level= number of flowers visited (ie. with at least evidence of pollen on stigma or one pollinarium removed)
```{r, eval=FALSE}
wdata=fitdata %>%
  group_by(individual) %>%
  summarise( n = sum(flower>0, na.rm=T),
             visits = sum(fvisit, na.rm=T),
             n_removed= sum(2-pollinaria_remaining, na.rm = T),
             n_pollinated= sum(pollen_on_stigma, na.rm= T)) %>%
  mutate(wfemale= n_pollinated/n, wmale= n_removed/(n*2), wvisit= visits/n)## Two pollinaria per flower
         
sum(wdata$visits>0, na.rm = TRUE)# 136 plants with at least one flower pollinated
```

#Merge trait and fitness data and check for outliers
```{r, fig.width= 7, fig.height= 6, echo= F, warning= F}
dat=merge(traitdata_clean, wdata, all.x = TRUE, by = "individual")

# Check for outliers
par(mfrow= c(3,3))

hist(dat$height)
hist(dat$flowers_open)
hist(dat$flowers)
hist(dat$flower_size)
hist(dat$spur_length)
hist(dat$spur_width)

data= dat %>% filter(!dat$flower_size <=2)
```


# Phenotypic correlation matrix

```{r, echo= F, warning= F}

P = cor(cbind(data$height, data$flower_size, data$spur_length, data$spur_width, data$flowers_open), use="pairwise")
colnames(P) = rownames(P) = c("height", "flower_size", "spur_length", "spur_width",
                              "open flowers")
signif(P, 3)
```

#Merge trait-fit data with community data 
```{r, eval=FALSE}
all_data<-merge(data, commudata, by= "individual", all.x= TRUE)

#save(all_data, file= "analyses/alldata_lapp.RData")
```

#Abundances of the co-flowering species
```{r, eval=FALSE}
sort(colSums(all_data[, 19:73]))

coflow= all_data[, 19:73]
preval= colMeans(coflow>0)
mean(preval)
abund= colSums(coflow)/colSums(coflow>0)

hist(preval)
hist(abund)
```

####HMSC model

To estimate the effects of the co-flowering community on relative reproductive fitness (pollination success) of D. lapponica, we set up a HMSC model in which we follow a reduced-rank regression approach (RRR) that reduces the number of dimensions of the animal-pollinated co-flowering species in the community and select those that best explain variation in the response (i.e., relative pollination succcess). In addition, we include as standard predictors in the HMSC model four phenotypic traits (plant height, flower size, spur lenght, spur width) and "n"= number of flowers scored to assess pollination success in each plant. Thus, we also estimate the selection gradients for each trait while accounting for effects of the co-flowering community. 
 

To test our model=m, we compare it with three alternative models: 1) a model that only includes the five traits as predictors= m1, 2) a model that includes the five traits and each animal-pollinated co-floweing species as predictors (Opedal et al 2022. J Evol Biol)= m2, and 3) a model that includes the five traits and a reduced rank regression of the non-animal pollinated co-flowering community= m3.


```{r, eval=FALSE}
#HMSC
indat= na.omit(all_data)##196 plants scored for pollination success

#Define the response variable
Y= cbind(indat$visits)
head(Y)
hist(Y)

#Define XData: height, flower size, spur length, spur width, and "n" flowers scored
XData= indat[, c(2,6,7,8,12)]
head(XData)
cor(XData)
```
#Select the animal pollinated co-flowering species

```{r, eval=FALSE}
coflo_data= indat[, 19:73]# co-flowering species

## Animal-pollinated co-flowering species

anim= c("Potentilla_erecta", "Primula_farinosa", "Pinguicula_vulgaris", "Succisa_pratensis", "Centaurea_jacea", "Prunella_grandiflora", "Prunella_vulgaris",
"Prunella_grandifloraxvulgaris", "Polygala_amarella", "Centarium_littorale", "Parnassia_palustris", "Antennaria_dioica", "Linum_catharticum", "Galium_boreale",
"Tetragonolobus_maritimus", "Scorzonera_humilis", "Tofieldia.calyculata", "Anthericum_ramosum", "Epipactis_palustris", "Platanthera_bifolia", "Gymnadenia_conopsea", "Gymnadenia_densiflora", "Gymnadenia_odoratissima", "Dactylorhiza_majalis_lapponica", "Inula.salicina", "Gentianella_uliginosa_cf", "Frangula_alnus_smallplant",
"Euphrasia_salisburgensis", "Vaccinium_vitis.idaea", "Asperula_tinctoria",
"Gymnadenia_sp", "Allium_schoenoprasum", "Leontodon_autumnalis", "Potentilla_reptans", "Calluna_vulgaris", "Dactylorhiza_incarnata_cruenta")
```

#Define XXXRData for the subset of anim-poll species
```{r, eval=FALSE}
XRRRData = coflo_data[, colnames(coflo_data) %in% anim]
XRRRData = coflo_data

#XRRRData = XRRRData[, match(anim, colnames(XRRRData))]
head(XRRRData)

sort(colSums(XRRRData))

XRRRData = XRRRData[, colSums(XRRRData>=1) >1]# Remove singleton species
length(XRRRData)#30 species in more than pne sample unit
```

Define the Xformula with the trait predictors (= XData)

```{r, eval=FALSE}
XFormula = as.formula(paste("~", paste0(colnames(XData), collapse=" + ")))
XFormula
```

Define the XRRRformula with the animal-pollinated species (= XRRRData) 

```{r, eval=FALSE}
XRRRFormula = as.formula(paste("~", " -1 + ", paste0(colnames(XRRRData), collapse=" + ")))
XRRRFormula
```

#Scale the XRRRData (the animal-poll co-flowering community)
```{r, eval=FALSE}
XRRRDataScaled = data.frame(scale(XRRRData))
dim(XRRRData)
```

Fit the HMSC models.

#HMSC with traits and the RRR of the animal-pollinated species as predictors (m)

```{r, eval=FALSE}
m = Hmsc(Y = as.matrix(Y/mean(Y)), XData=XData, XFormula=XFormula,
         distr="normal", 
         XRRRData=XRRRDataScaled, XRRRFormula=XRRRFormula, ncRRR=1, XRRRScale = TRUE)
```
#Alternative models:

#HMSC only with traits as predictors (m1)

```{r, echo=FALSE}
m1 = Hmsc(Y = as.matrix(Y/mean(Y)), XData=XData, XFormula=XFormula,
          distr="normal")
```
#HMSC with traits and each animal-pollinated species as predictors (m2)

Here, we need another XData object (= XData2) that includes the traits and each animal-poll co-flowering species (XRRRData) and define an Xformula for it (= XFormula2)

```{r, echo=FALSE}
XData2 = data.frame(XData, XRRRData)
XFormula2 = as.formula(paste("~", paste0(colnames(XData2), collapse=" + ")))
XFormula2

m2 = Hmsc(Y = as.matrix(Y/mean(Y)), XData=XData2, XFormula=XFormula2,
          distr="normal")
```
#HMSC with traits and the RRR of the non-animal pollinated species as predictors (m3)

Here, we need another XRRRData object (= XRRRData2) for the non-animal pollinated species. As we did before, we remove singletons and scale the XRRRRData2 object.

Then we define the XRRRformula (XRRRFormula2)


```{r, echo=FALSE}
XRRRData2= coflo_data[!(colnames(coflo_data) %in% anim)]

XRRRData2 = XRRRData2[, colSums(XRRRData2>=1) >1]# 11 sp wihout singletons

XRRRDataScaled2 = data.frame(scale(XRRRData2))
dim(XRRRData2)

XRRRFormula2 = as.formula(paste("~", " -1 + ", paste0(colnames(XRRRData2), collapse=" + ")))

XRRRFormula2

m3 = Hmsc(Y = as.matrix(Y/mean(Y)), XData=XData, XFormula=XFormula,
         distr="normal", XRRRData=XRRRDataScaled2, XRRRFormula=XRRRFormula2, ncRRR=1, XRRRScale = TRUE)
```

Now we set the sampling parameters and fit the four models.
```{r, echo=FALSE}
samples = 1500
thin = 100
transient = .5*(thin*samples)
adaptNf = 0.4*(thin*samples)
nChains = 1

models= list(m, m1, m2, m3)
for(i in 1:4){
  models[[i]]= sampleMcmc(models[[i]], samples = samples, thin = thin, adaptNf=rep(adaptNf, m$nr), 
               transient = transient, nChains = nChains)}

#save(models, file ="analyses/models_pollsuccess_lap.RData")

#load(file= "analyses/models_pollsuccess_lap.RData")

#m_all= sampleMcmc(m, samples = samples, thin = thin, #adaptNf=rep(adaptNf, m$nr), transient = transient, nChains = nChains)

#save(m_all, file ="analyses/model-allcommunity_pollsuccess_lap.RData")

```

Check effective sample sizes
```{r, echo=FALSE}
post= convertToCodaObject(models[[1]], covNamesNumbers = c(T,F))
post1= convertToCodaObject(models[[2]], covNamesNumbers = c(T,F))
post2= convertToCodaObject(models[[3]], covNamesNumbers = c(T,F))
post3= convertToCodaObject(models[[4]], covNamesNumbers = c(T,F))

effectiveSize(post$Beta)

post= convertToCodaObject(m_all, covNamesNumbers = c(T,F))

effectiveSize(post$Beta)

```

Posterior support for the animal-pollinated coflowering community

```{r, echo=FALSE}
#Posterior support for the RRR animal-pollinated coflowering community
getPostEstimate(models[[1]], "Beta")

postsup= getPostEstimate(models[[4]], "Beta")$support[2:7, ]

postsup[which(postsup<0.5)] = 1 - postsup[which(postsup<0.5)]
postsup
```


```{r, echo=FALSE}
getPostEstimate(m_all, "Beta")

postsup= getPostEstimate(m_all, "Beta")$support[2:7, ]

postsup[which(postsup<0.5)] = 1 - postsup[which(postsup<0.5)]

postsup

pred= computePredictedValues(m_all)
MF= evaluateModelFit(hM= m_all, predY = pred)
MF#47.9% same variance explained by animal-pollinated species alone


```

MCMC convergence

```{r, echo=FALSE}
plot(post$Beta[,7])
```


```{r, echo=FALSE}
# Temp. posterior of wRRR
bind0 = function(...) {abind(..., along = 0)}
postList = poolMcmcChains(models[[1]]$postList, chainIndex = 1:length(models[[1]]$postList), 
                          start = 1, thin = 1)
valList = lapply(postList, function(a) a[["wRRR"]])
wRRR_post = do.call(bind0, valList)

dim(wRRR_post)

for(i in 1:30){
  plot(wRRR_post[,1,i], type="l")
}
```

#Model fitting

Now we evaluate the explanatory power of the model "m" by computing the R^2 values and compare with alternative models (m1, m2 and m3)
```{r, echo=FALSE}
MF_results= matrix(NA, nrow= 2, ncol= 4)
for(i in 1:4){
  m= models[[i]]
  pred= computePredictedValues(m)
        MF= evaluateModelFit(hM= m, predY = pred)
        MF_results[1,i]= mean(MF$R2)
}

MF_results
```

Now we evaluate the predictive power of the model "m" and of the alternative models by using 5-fold cross validation
```{r, echo=FALSE}
partition= createPartition(m, nfolds=5)

for(i in 1:4){
  m= models[[i]]
  pred_CV = computePredictedValues(m, partition)
  MF_CV= evaluateModelFit(hM= m, predY = pred_CV)
  MF_results[2, i]= mean(MF_CV$R2)
}

MF_results

colnames(MF_results)= c("RRRco", "MR", "MRco", "RRRn")
rownames(MF_results)=  c("MF", "MF_cV")

MF_results= as.data.frame(MF_results)

save(MF_results, file="results/MF_pollsuccess_lap.RData")
```

#Obtain the selection gradients for m
```{r, echo=FALSE}
nX = ncol(models[[1]]$XData)
nX

#beta_raw_post = post$Beta[,2:(nX+1)][[1]] #posterior for betas
beta_raw_post = post$Beta[,2:(5+1)][[1]]
head(beta_raw_post)

beta_var_post = matrix(NA, nrow=nrow(beta_raw_post), ncol=nX)
for(i in 1:nX){
  beta_var_post[,i] = beta_raw_post[,i]*sd(XData[,i])
}

beta_mean_post = matrix(NA, nrow=nrow(beta_raw_post), ncol=nX)
for(i in 1:nX){
  beta_mean_post[,i] = beta_raw_post[,i]*mean(XData[,i])
}

beta_raw = apply(beta_raw_post, 2, mean)
beta_raw_lower = apply(beta_raw_post, 2, quantile, c(0.025))
beta_raw_upper = apply(beta_raw_post, 2, quantile, c(0.975))

beta_var = apply(beta_var_post, 2, mean)
beta_var_lower = apply(beta_var_post, 2, quantile, c(0.025))
beta_var_upper = apply(beta_var_post, 2, quantile, c(0.975))

beta_mean = apply(beta_mean_post, 2, mean)
beta_mean_lower = apply(beta_mean_post, 2, quantile, c(0.025))
beta_mean_upper = apply(beta_mean_post, 2, quantile, c(0.975))

resmat_RRR = data.frame(beta_raw = round(beta_raw, 3),
                        L = round(beta_raw_lower, 3),
                        U = round(beta_raw_upper, 3),
                        beta_var = round(beta_var, 3),
                        L = round(beta_var_lower, 3),
                        U = round(beta_var_upper, 3),
                        beta_mean = round(beta_mean*100, 3),
                        L = round(beta_mean_lower, 3),
                        U = round(beta_mean_upper, 3))

betaRRR = post$Beta[,(nX+2):(models[[1]]$ncRRR+(nX+1))][[1]] #posterior for beta_RRR
#betaRRR = post$Beta[,(5+2):(m$ncRRR+(5+1))][[1]] #posterior for beta_RRR
length(betaRRR)

# The anim-pollinated co-flowering community axis"
dim(models[[1]]$XRRR)

comp1_post = matrix(NA, nrow=length(betaRRR), ncol=models[[1]]$ny)
for(i in 1:length(betaRRR)){
  comp1_post[i,]=models[[1]]$XRRR %*% as.matrix((wRRR_post[i,1,]))
}

beta_comp1_post=NULL
for(i in 1:1000){
  beta_comp1_post[i]=betaRRR[i]*sd(comp1_post[i,])
}

resmat_RRR[nrow(resmat_RRR)+1,]=c("NA","NA","NA", 
                 round(mean(beta_comp1_post), 3),
                 round(quantile(beta_comp1_post, c(0.025)), 3),
                 round(quantile(beta_comp1_post, c(0.975)), 3),
                 "NA", "NA","NA")

kable(resmat_RRR)
```
#Obatin selection gradients for m1

```{r, echo=FALSE}
nX = ncol(models[[2]]$XData)
nX

#beta_raw_post = post$Beta[,2:(nX+1)][[1]] #posterior for betas
beta_raw_post = post1$Beta[,2:(5+1)][[1]]

head(beta_raw_post)

beta_var_post = matrix(NA, nrow=nrow(beta_raw_post), ncol=nX)
for(i in 1:nX){
  beta_var_post[,i] = beta_raw_post[,i]*sd(XData[,i])
}

beta_mean_post = matrix(NA, nrow=nrow(beta_raw_post), ncol=nX)
for(i in 1:nX){
  beta_mean_post[,i] = beta_raw_post[,i]*mean(XData[,i])
}

beta_raw = apply(beta_raw_post, 2, mean)
beta_raw_lower = apply(beta_raw_post, 2, quantile, c(0.025))
beta_raw_upper = apply(beta_raw_post, 2, quantile, c(0.975))

beta_var = apply(beta_var_post, 2, mean)
beta_var_lower = apply(beta_var_post, 2, quantile, c(0.025))
beta_var_upper = apply(beta_var_post, 2, quantile, c(0.975))

beta_mean = apply(beta_mean_post, 2, mean)
beta_mean_lower = apply(beta_mean_post, 2, quantile, c(0.025))
beta_mean_upper = apply(beta_mean_post, 2, quantile, c(0.975))


resmat_M1 = data.frame(beta_raw = round(beta_raw, 3),
                        L = round(beta_raw_lower, 3),
                        U = round(beta_raw_upper, 3),
                        beta_var = round(beta_var, 3),
                        L = round(beta_var_lower, 3),
                        U = round(beta_var_upper, 3),
                        beta_mean = round(beta_mean*100, 3),
                        L = round(beta_mean_lower, 3),
                        U = round(beta_mean_upper, 3))

resmat_M1[nrow(resmat_M1)+1,]= rep(c("NA"), times= 9)


kable(resmat_M1)
```
#Selection gradients of m2

```{r, echo=FALSE}
nX = ncol(models[[3]]$XData)
nX

beta_raw_post = post2$Beta[,2:(5+1)][[1]] #posterior for betas
#beta_raw_post = post2$Beta[,2:(33+1)][[1]] 
head(beta_raw_post)


beta_var_post = matrix(NA, nrow=nrow(beta_raw_post), ncol=ncol(beta_raw_post))
  for(i in 1:ncol(beta_raw_post)){
    beta_var_post[,i] = beta_raw_post[,i]*sd(models[[3]]$XData[,i])
  }
  
  beta_mean_post = matrix(NA, nrow=nrow(beta_raw_post), ncol=ncol(beta_raw_post))
  for(i in 1:ncol(beta_raw_post)){
    beta_mean_post[,i] = beta_raw_post[,i]*mean(models[[3]]$XData[,i])
  }

beta_raw = apply(beta_raw_post, 2, mean)
beta_raw_lower = apply(beta_raw_post, 2, quantile, c(0.025))
beta_raw_upper = apply(beta_raw_post, 2, quantile, c(0.975))

beta_var = apply(beta_var_post, 2, mean)
beta_var_lower = apply(beta_var_post, 2, quantile, c(0.025))
beta_var_upper = apply(beta_var_post, 2, quantile, c(0.975))

beta_mean = apply(beta_mean_post, 2, mean)
beta_mean_lower = apply(beta_mean_post, 2, quantile, c(0.025))
beta_mean_upper = apply(beta_mean_post, 2, quantile, c(0.975))


resmat_M2 = data.frame(beta_raw = round(beta_raw, 3),
                        L = round(beta_raw_lower, 3),
                        U = round(beta_raw_upper, 3),
                        beta_var = round(beta_var, 3),
                        L = round(beta_var_lower, 3),
                        U = round(beta_var_upper, 3),
                        beta_mean = round(beta_mean*100, 3),
                        L = round(beta_mean_lower, 3),
                        U = round(beta_mean_upper, 3))
resmat_M2[nrow(resmat_M2)+1,]= rep(c("NA"), times= 9)

kable(resmat_M2)
```

#Selection gradients of m3

```{r, echo=FALSE}
nX = ncol(models[[4]]$XData)
nX

#beta_raw_post = post$Beta[,2:(nX+1)][[1]] #posterior for betas
beta_raw_post = post3$Beta[,2:(5+1)][[1]]
head(beta_raw_post)

beta_var_post = matrix(NA, nrow=nrow(beta_raw_post), ncol=nX)
for(i in 1:nX){
  beta_var_post[,i] = beta_raw_post[,i]*sd(XData[,i])
}

beta_mean_post = matrix(NA, nrow=nrow(beta_raw_post), ncol=nX)
for(i in 1:nX){
  beta_mean_post[,i] = beta_raw_post[,i]*mean(XData[,i])
}

beta_raw = apply(beta_raw_post, 2, mean)
beta_raw_lower = apply(beta_raw_post, 2, quantile, c(0.025))
beta_raw_upper = apply(beta_raw_post, 2, quantile, c(0.975))

beta_var = apply(beta_var_post, 2, mean)
beta_var_lower = apply(beta_var_post, 2, quantile, c(0.025))
beta_var_upper = apply(beta_var_post, 2, quantile, c(0.975))

beta_mean = apply(beta_mean_post, 2, mean)
beta_mean_lower = apply(beta_mean_post, 2, quantile, c(0.025))
beta_mean_upper = apply(beta_mean_post, 2, quantile, c(0.975))

resmat_M3 = data.frame(beta_raw = round(beta_raw, 3),
                        L = round(beta_raw_lower, 3),
                        U = round(beta_raw_upper, 3),
                        beta_var = round(beta_var, 3),
                        L = round(beta_var_lower, 3),
                        U = round(beta_var_upper, 3),
                        beta_mean = round(beta_mean*100, 3),
                        L = round(beta_mean_lower, 3),
                        U = round(beta_mean_upper, 3))

resmat_M3[nrow(resmat_M3)+1,]= rep(c("NA"), times= 9)

kable(resmat_M3)

######
betaRRR = post3$Beta[,(nX+2):(models[[4]]$ncRRR+(nX+1))][[1]] #posterior for beta_RRR
#betaRRR = post$Beta[,(5+2):(m$ncRRR+(5+1))][[1]] #posterior for beta_RRR
length(betaRRR)

## The non-anim-pollinated co-flowering community axis"
dim(models[[4]]$XRRR)

# Temp. posterior of wRRR
bind0 = function(...) {abind(..., along = 0)}
postList = poolMcmcChains(models[[4]]$postList, chainIndex = 1:length(models[[4]]$postList), 
                          start = 1, thin = 1)
valList = lapply(postList, function(a) a[["wRRR"]])
wRRR_postn = do.call(bind0, valList)


comp1_post = matrix(NA, nrow=length(betaRRR), ncol=models[[4]]$ny)
for(i in 1:length(betaRRR)){
  comp1_post[i,]=models[[4]]$XRRR %*% as.matrix((wRRR_postn[i,1,]))
}

beta_comp1_post=NULL
for(i in 1:1000){
  beta_comp1_post[i]=betaRRR[i]*sd(comp1_post[i,])
}

resmat_M3[nrow(resmat_M3)+1,]=c("NA","NA","NA", 
                 round(mean(beta_comp1_post), 3),
                 round(quantile(beta_comp1_post, c(0.025)), 3),
                 round(quantile(beta_comp1_post, c(0.975)), 3),
                 "NA","NA","NA")

kable(resmat_M3)
```

#Plot gradients
```{r, fig.height= 5.8, fig.width= 7, echo=FALSE}
###Plot gradients----

beta_pol_lap= list(resmat_RRR, resmat_M1, resmat_M2, resmat_M3)

#save(beta_pol_lap, file="analyses/betas_poll_lap.RData")

load(file= "analyses/betas_poll_lap.RData")

mods= c("RRRco", "MR", "MRco", "RRRn")

#Variance-scaled Betas

summary_var = matrix(NA, nrow = 6, ncol = length(mods))
for(i in 1:length(mods)){
  summary_var[,i] = round(as.numeric(beta_pol_lap[[i]]$beta_var), 3)
}

colnames(summary_var) = mods
rownames(summary_var) = rownames(beta_pol_lap[[1]])
summary_var = t(summary_var)
summary_var

upper_var = matrix(NA, nrow = 6, ncol = length(mods))
for(i in 1:length(mods)){
  upper_var[,i] = round(as.numeric(beta_pol_lap[[i]]$U.1), 3)
}

colnames(upper_var) = mods
rownames(upper_var) = rownames(beta_pol_lap[[1]])
upper_var = t(upper_var)
upper_var

lower_var = matrix(NA, nrow = 6, ncol = length(mods))
for(i in 1:length(mods)){
  lower_var[,i] = round(as.numeric(beta_pol_lap[[i]]$L.1), 3)
}

colnames(lower_var) = mods
rownames(lower_var) = rownames(beta_pol_lap[[1]])
lower_var = t(lower_var)

summary_var[4,6] = summary_var[4,6]*-1
lower_var[4,6] = lower_var[4,6]*-1
upper_var[4,6] = upper_var[4,6]*-1
summary_var


bdfv = data.frame(summary_var, lower_var, upper_var)
names(bdfv)= c("B_PlantHeight", "B_FlwSize", "B_SpurLength", "B_SpurWidth", "B_nflow", "B_community", rep("Lower", times=6), rep("Upper", times=6))

bdfv <- cbind(model = rownames(bdfv), bdfv)

bdfmv= melt(setDT(bdfv), measure = patterns("^B", "^Lower", "^Upper"), value.name = c("Beta_var", "Lower", "Upper"), variable.name = "trait", variable.factor = "trait")
bdfmv$model= as.factor(bdfmv$model)


bdf2v= bdfmv %>% mutate(trait= recode(trait, "1"= "Plant height", "2"= "Flower size", "3"= "Spur length", "4"= "Spur width", "5"= "Open Flowers", "6"= "Community"), model= factor(model, levels=c("RRRco", "MR","MRco", "RRRn")))

bdf2vn= bdf2v[complete.cases(bdf2v), ]

#bdf2v.n= bdf2v %>% filter(trait!= "Flw_n")%>%
 # droplevels()
#bdf2v.n , ,

VARplot_pol_lap= ggplot(bdf2vn, aes(x=model, y=Beta_var, colour=factor(model))) +
  geom_pointrange(aes(ymin = Lower, ymax = Upper), linetype = "solid", size=0.75)+ 
  #geom_errorbar(aes(ymin = Lower, ymax = Upper), linetype = "solid")+
  labs(y= expression(beta ~ "variance-standardized selection gradients"), x= expression(italic("Dactylorhiza lapponica"), size=12)) +
scale_y_continuous(breaks = c(-0.60, -0.40, -0.20, 0, 0.20, 0.40, 0.60, 0.80), limits=c(-0.60, 1))+
  facet_wrap(~ trait, nrow = 1L, strip.position = "top")+
  theme_bw(base_size = 15)+
  theme(text = element_text(size=15), axis.text.x= element_blank(),  axis.ticks.x = element_blank(), legend.title= element_blank(), legend.position="top", panel.grid.major.x = element_blank(), panel.grid.minor.x = element_blank(), panel.grid.major.y = element_blank(), panel.grid.minor.y = element_blank(),
         strip.text = element_text(size= 11))+ 
  geom_hline(yintercept=0, linetype="dashed", color = "black")

VARplot_pol_lap
```


```{r, fig.height= 7.5, fig.width= 15, echo=FALSE}
ggarrange(VARplot_pol_lap, VARplot_pol_maj, ncol=2, nrow=1)
```


```{r, fig.height= 7.5, fig.width= 15, echo=FALSE}
ggarrange(VARplot_pol_lap,VARplot_fset_lap, ncol=1, nrow=2)

```

