---
title: 'D.lapponica: Selection analyses via pollination success'
author: '"Yedra Garcia"'
date: "2023-12-07"
output: html_document
---

```{r, eval=FALSE}
library(tidyverse)
library(dplyr)
library(Hmsc)
library(abind)
library(mgcv)
library(knitr)
library(ggplot2)
library(reshape2)
library(data.table)
library(ggpubr)
library(forcats)
library(ggplot2)
```

#Loading trait, fitness, co-flowering community and animal-poll species data
```{r, eval=FALSE}
traitdata= read.csv("data/data_CRO/Gotland_trait_data.csv", header=T, sep= ";", dec=",") %>% mutate(individual= as.character(individual)) 

fitdata= read.csv("data/data_CRO/Gotland_fitness_data.csv", header=T, sep= ";",) %>% mutate(individual= as.character(individual))

commudata= read.csv("data/data_CRO/Gotland_community_data.csv", header= T, sep= ";", fileEncoding="latin1")%>% mutate(individual= as.character(individual), Primula_farinosa= as.integer(factor(Primula_farinosa)))%>% dplyr::select(-c(57:60))##because 4 empty extra-columns at #the end

```

#Remove unnecessary columns and rename trait variables from trait data
```{r, eval=FALSE}
traitdata_clean= traitdata %>% select(-c(2:5, 13, 14, 18:23))%>% 
  dplyr::rename(height= height_cm, flower_size= flower_size_mm, spur_length= spur_length_mm, spur_width= spur_width_mm,
         flowers= No_of_flowers)
```

#Estimate visitation at flower level
```{r, eval=FALSE}
fitdata = na.omit(fitdata)

fitdata= fitdata %>% mutate(pollinaria_removed= as.numeric(pollinaria_removed))

fitdata= fitdata%>% mutate(fvisit= 1*((pollen_on_stigma+ pollinaria_removed)>0))#Flower
#pollinated when it has at least presence of pollen on stigma or one pollinarium removed

```

#Estimate pollination success at the individual level= number of flowers visited (ie. with at least evidence of pollen on stigma or one pollinarium removed)
```{r, eval=FALSE}
wdata=fitdata %>%
  group_by(individual) %>%
  summarise( n = sum(flower>0, na.rm=T),
             visits = sum(fvisit, na.rm=T),
             n_removed= sum(2-pollinaria_remaining, na.rm = T),
             n_pollinated= sum(pollen_on_stigma, na.rm= T)) %>%
  mutate(wfemale= n_pollinated/n, wmale= n_removed/(n*2), wvisit= visits/n)## Two pollinaria per flower

sum(wdata$wvisit>0, na.rm = TRUE)# 136 plants with at least one flower pollinated

summary(wdata)
```

#Merge trait and fitness data and check for outliers
```{r, fig.width= 7, fig.height= 6, echo= F, warning= F}
dat=merge(traitdata_clean, wdata, all.x = TRUE, by = "individual")

# Check for outliers
par(mfrow= c(3,3))

hist(dat$height)
hist(dat$flowers_open)
hist(dat$flowers)
hist(dat$flower_size)
hist(dat$spur_length)
hist(dat$spur_width)

data= dat %>% filter(!dat$flower_size <=2)

```

#Summary stats
```{r, echo= F, warning= F}
summary_table= data.frame(
  variable = names(data)[sapply(data, is.numeric)],
  mean = sapply(data[, sapply(data, is.numeric)], mean, na.rm = TRUE),
  SD = sapply(data[, sapply(data, is.numeric)], sd, na.rm = TRUE)
)

print(summary_table)

```


# Phenotypic correlation matrix

```{r, echo= F, warning= F}
Plap = cor(cbind(data$height, data$flower_size, data$spur_length, data$spur_width, data$flowers_open, data$wmale, data$wfemale), use="pairwise")
colnames(Plap) = rownames(Plap) = c("height", "flower_size", "spur_length", "spur_width",
                              "open flowers", "removal", "deposition")
Plap
```


```{r, echo= F, warning= F}
names(data)
summary_poll= data.frame(mean= apply(data[,c(13:15)], 2, mean, na.rm=T),
                         sd= apply(data[, c(13:15)], 2, sd, na.rm=T),
                         median= apply(data[,c(13:15)], 2, median, na.rm=T),
                         n_obs= apply(data[, c(13:15)], 2, function(x) sum(!is.na(x), na.rm=T)),
                         n_yes= apply(data[, c(13:15)], 2, function(x) sum(x>0, na.rm=T)))
summary_poll$cv= summary_poll$sd/ summary_poll$mean
signif(summary_poll, 4)

```

#Merge trait-fit data with community data 
```{r, eval=FALSE}
all_data=merge(data, commudata, by= "individual", all.x= TRUE)

#all_data= all_data[, -51]
names(all_data)

#save(all_data, file= "analyses/alldata_lapp.RData")
```

#Abundances of co-flowering species
```{r, fig.width= 7, fig.height= 4, echo= F, warning= F}
sort(colSums(all_data[, 19:73]))

coflow= all_data[, c(19:73)]
preval= colMeans(coflow>0)
mean(preval)
abund= colSums(coflow)/colSums(coflow>0)

par(mfcol= c(1,2))
hist(preval)
hist(abund)
```

####1.HMSC model

Hello! We are going to set up a model in Hmsc to estimate community context effects (here co-flowering community composition) on relative fitness (via pollination success) of the orchid D. lapponica. To do that, we follow a reduced-rank regression approach (RRR) that reduces the number of dimensions of the animal-pollinated surrounding co-flowering community of each D. lapponica individual into one or a few composite variables (i.e. "community axis") that best explain variation in the response variable (i.e. relative pollination success). In addition, we include as standard predictors in the HMSC model four phenotypic traits (plant height, flower size, spur length, spur width) and "n"= number of flowers scored to assess pollination success in each plant (which here corresponded to number of open flowers). Thus, we also estimate the linear selection gradients for each trait while accounting for effects of the co-flowering community. 
 

To test the suitability of our model "m" (community model), we compare with three alternative models: 1) a model that only includes the traits as predictors "m1", 2) a model that includes the traits and each animal-pollinated co-flowering species as predictors (Opedal et al 2022. J Evol Biol) "m2", and 3) a model that includes the traits and a reduced rank regression of the non-animal pollinated surrounding species in the co-flowering community "m3" (i.e. a natural control using plant species for which we would not expect pollinator-mediated plant-plant interactions).


```{r, eval=FALSE}
#HMSC
indat= na.omit(all_data)##196 plants

#Define the response variable
Y= cbind(indat$visits)
hist(Y)

#Define XData: height, flower size, spur length, spur width, and "n" flowers scored
XData= indat[, c(2,6,7,8,12)]
head(XData)
cor(XData)
```
#Select the animal pollinated co-flowering species

```{r, eval=FALSE}
coflo_data= indat[, 19:73]# co-flowering species

## Animal-pollinated co-flowering species

anim= c("Potentilla_erecta", "Primula_farinosa", "Pinguicula_vulgaris", "Succisa_pratensis", "Centaurea_jacea", "Prunella_grandiflora", "Prunella_vulgaris", "Dactylorhiza_majalis_lapponica",
"Prunella_grandifloraxvulgaris", "Polygala_amarella", "Centarium_littorale", "Parnassia_palustris", "Antennaria_dioica", "Linum_catharticum", "Galium_boreale",
"Tetragonolobus_maritimus", "Scorzonera_humilis", "Tofieldia.calyculata", "Anthericum_ramosum", "Epipactis_palustris", "Platanthera_bifolia", "Gymnadenia_conopsea", "Gymnadenia_densiflora", "Gymnadenia_odoratissima", "Inula.salicina", "Gentianella_uliginosa_cf", "Frangula_alnus_smallplant",
"Euphrasia_salisburgensis", "Vaccinium_vitis.idaea", "Asperula_tinctoria",
"Gymnadenia_sp", "Allium_schoenoprasum", "Leontodon_autumnalis", "Potentilla_reptans", "Calluna_vulgaris", "Dactylorhiza_incarnata_cruenta")
```

#Define XXXRData for the subset of anim-poll species
```{r, eval=FALSE}
XRRRData = coflo_data[, colnames(coflo_data) %in% anim]

XRRRData = XRRRData[, match(anim, colnames(XRRRData))]
head(XRRRData)
sort(colSums(XRRRData))

XRRRData = XRRRData[, colSums(XRRRData>=1) >1]# Remove singleton species

head(XRRRData)
```

Define the Xformula with the trait predictors (= XData)

```{r, eval=FALSE}
XFormula = as.formula(paste("~", paste0(colnames(XData), collapse=" + ")))
XFormula
```

Define the XRRRformula with the animal-pollinated species (= XRRRData) 

```{r, eval=FALSE}
XRRRFormula = as.formula(paste("~", " -1 + ", paste0(colnames(XRRRData), collapse=" + ")))
XRRRFormula
```

Scale the XRRRData (the animal-pollinated co-flowering community)
```{r, eval=FALSE}
XRRRDataScaled = data.frame(scale(XRRRData))
dim(XRRRData)
```

####1.2.Fit the HMSC models.

#HMSC model with traits and the RRR of the animal-pollinated species as predictors (m)

```{r, eval=FALSE}
m = Hmsc(Y = as.matrix(Y/mean(Y)), XData=XData, XFormula=XFormula,
         distr="normal", 
         XRRRData=XRRRDataScaled, XRRRFormula=XRRRFormula, ncRRR=1, XRRRScale = TRUE)
```
#Alternative models:

#HMSC model only with traits as predictors (m1)

```{r, echo=FALSE}
m1 = Hmsc(Y = as.matrix(Y/mean(Y)), XData=XData, XFormula=XFormula,
          distr="normal")
```
#HMSC model with traits and each animal-pollinated species as predictors (m2)

Here, we need another XData object (= XData2) that includes the traits and each animal-poll co-flowering species (XRRRData) and define an Xformula for it (= XFormula2)

```{r, echo=FALSE}
XData2 = data.frame(XData, XRRRData)
XFormula2 = as.formula(paste("~", paste0(colnames(XData2), collapse=" + ")))
XFormula2

m2 = Hmsc(Y = as.matrix(Y/mean(Y)), XData=XData2, XFormula=XFormula2,
          distr="normal")
```
#HMSC with traits and the RRR of the non-animal pollinated species as predictors (m3)

Here, we need another XRRRData object (= XRRRData2) for the non-animal pollinated species. As we did before, we remove singletons and scale the XRRRRData2 object.

```{r, echo=FALSE}
XRRRData2= coflo_data[!(colnames(coflo_data) %in% anim)]

XRRRData2 = XRRRData2[, colSums(XRRRData2>=1) >1]

XRRRDataScaled2 = data.frame(scale(XRRRData2))
dim(XRRRData2)
```

Then we define the XRRRformula (XRRRFormula2)

```{r, echo=FALSE}
XRRRFormula2 = as.formula(paste("~", " -1 + ", paste0(colnames(XRRRData2), collapse=" + ")))

XRRRFormula2
```


```{r, echo=FALSE}
m3 = Hmsc(Y = as.matrix(Y/mean(Y)), XData=XData, XFormula=XFormula,
         distr="normal", XRRRData=XRRRDataScaled2, XRRRFormula=XRRRFormula2, ncRRR=1, XRRRScale = TRUE)
```

Now we set the sampling parameters and fit the four models.
```{r, echo=FALSE}
samples = 1500
thin = 100
transient = .5*(thin*samples)
adaptNf = 0.4*(thin*samples)
nChains = 1

models= list(m, m1, m2, m3)
for(i in 1:4){
  models[[i]]= sampleMcmc(models[[i]], samples = samples, thin = thin, adaptNf=rep(adaptNf, m$nr), 
               transient = transient, nChains = nChains)}

#save(models, file ="analyses/models_pollsuccess_lap.RData")

load(file= "analyses/models_pollsuccess_lap.RData")

```
Evaluating sample sizes and model convergence

#Check effective sample sizes of each HMSC model
```{r, echo=FALSE}
post= convertToCodaObject(models[[1]], covNamesNumbers = c(T,F))
post1= convertToCodaObject(models[[2]], covNamesNumbers = c(T,F))
post2= convertToCodaObject(models[[3]], covNamesNumbers = c(T,F))
post3= convertToCodaObject(models[[4]], covNamesNumbers = c(T,F))

effectiveSize(post$Beta)

```

Posterior support for each parameter of the HMSC community model (m) with the RRR animal-pollinated co-flowering community

```{r, echo=FALSE}
#Posterior support for the RRR animal-pollinated co-flowering community
getPostEstimate(models[[1]], "Beta")

getPostEstimate(models[[1]], "wRRR")#weights for each co-flowering plant species

```
#Posterior support for each model parameter

```{r, echo=FALSE}
postsup= getPostEstimate(models[[1]], "Beta")$support[2:7, ]

postsup[which(postsup<0.5)] = 1 - postsup[which(postsup<0.5)]
postsup
```

#Check MCMC convergence

```{r, echo=FALSE}
plot(post$Beta[,2:7])
```


```{r, echo=FALSE}
# Temp. posterior of wRRR (the RRR on the animal-pollinated co-flowering species, 29 co-flowering species and conspecifics)
bind0 = function(...) {abind(..., along = 0)}
postList = poolMcmcChains(models[[1]]$postList, chainIndex = 1:length(models[[1]]$postList), 
                          start = 1, thin = 1)
valList = lapply(postList, function(a) a[["wRRR"]])
wRRR_post = do.call(bind0, valList)

dim(wRRR_post)

for(i in 1:30){
  plot(wRRR_post[,1,i], type="l")
}
```
#Posterior support for each parameter of the HMSC community model (m3) with the RRR on the non-animal-pollinated co-flowering community (NP)
```{r, echo= FALSE}

#Posterior support for the HMSC model (m3) on the non-animal pollinated co-flowering community

postsup_np= getPostEstimate(models[[4]], "Beta")$support[2:7, ]


postsup_np[which(postsup_np<0.5)] = 1 - postsup_np[which(postsup_np<0.5)]
postsup_np

```

#Model fitting

Now we evaluate the explanatory power of our main model "m" (RRR animal-pollinated co-flowering species) by computing the R^2 values and compare with the explanatory power of the alternative models (m1, m2 and m3)
```{r, echo=FALSE}
MF_results= matrix(NA, nrow= 2, ncol= 4)
for(i in 1:4){
  m= models[[i]]
  pred= computePredictedValues(m)
        MF= evaluateModelFit(hM= m, predY = pred)
        MF_results[1,i]= mean(MF$R2)
}

MF_results
```

Now we evaluate the predictive power of the model "m" and of the alternative models by using 5-fold cross validation
```{r, echo=FALSE}
partition= createPartition(m, nfolds=5)

for(i in 1:4){
  m= models[[i]]
  pred_CV = computePredictedValues(m, partition)
  MF_CV= evaluateModelFit(hM= m, predY = pred_CV)
  MF_results[2, i]= mean(MF_CV$R2)
}

MF_results

colnames(MF_results)= c("RRRco", "MR", "MRco", "RRRn")
rownames(MF_results)=  c("MF", "MF_cV")

MF_results= as.data.frame(MF_results)

#save(MF_results, file="results/MF_pollsuccess_lap.RData")

MF_results# Table1
```

Next thing we will do is to estimate the partial regression coefficients for each trait, which correspond to the linear selection gradients through pollination success, and for the co-flowering community axis.

#Obtain the linear selection gradients (Beta) for model "m"
```{r, echo=FALSE}
nX = ncol(models[[1]]$XData)
nX

#beta_raw_post = post$Beta[,2:(nX+1)][[1]] #posterior for betas
beta_raw_post = post$Beta[,2:(5+1)][[1]]
head(beta_raw_post)

#Variance-scaled betas
beta_var_post = matrix(NA, nrow=nrow(beta_raw_post), ncol=nX)
for(i in 1:nX){
  beta_var_post[,i] = beta_raw_post[,i]*sd(XData[,i])
}

#Mean-scaled betas (this only applies to mean-scaled selection gradients, as the community axis is not on a ratio scale, and thus mean-scale is not meaningful)
beta_mean_post = matrix(NA, nrow=nrow(beta_raw_post), ncol=nX)
for(i in 1:nX){
  beta_mean_post[,i] = beta_raw_post[,i]*mean(XData[,i])
}

#Get credible intervals
beta_raw = apply(beta_raw_post, 2, mean)
beta_raw_lower = apply(beta_raw_post, 2, quantile, c(0.025))
beta_raw_upper = apply(beta_raw_post, 2, quantile, c(0.975))

beta_var = apply(beta_var_post, 2, mean)
beta_var_lower = apply(beta_var_post, 2, quantile, c(0.025))
beta_var_upper = apply(beta_var_post, 2, quantile, c(0.975))

beta_mean = apply(beta_mean_post, 2, mean)
beta_mean_lower = apply(beta_mean_post, 2, quantile, c(0.025))
beta_mean_upper = apply(beta_mean_post, 2, quantile, c(0.975))

#Put it into a table
resmat_RRR = data.frame(beta_raw = round(beta_raw, 3),
                        L = round(beta_raw_lower, 3),
                        U = round(beta_raw_upper, 3),
                        beta_var = round(beta_var, 3),
                        L = round(beta_var_lower, 3),
                        U = round(beta_var_upper, 3),
                        beta_mean = round(beta_mean*100, 3),
                        L = round(beta_mean_lower, 3),
                        U = round(beta_mean_upper, 3))

betaRRR = post$Beta[,(nX+2):(models[[1]]$ncRRR+(nX+1))][[1]] #posterior for beta_RRR (the community axis)
#betaRRR = post$Beta[,(5+2):(m$ncRRR+(5+1))][[1]] #posterior for beta_RRR
length(betaRRR)

# Adding the regression coefficient (B) for the animal-pollinated co-flowering community axis"
#For the community axis, only variance-scaled B is reported (is not on a ratio scale, mean-scaled not meaningful).

dim(models[[1]]$XRRR)

comp1_post = matrix(NA, nrow=length(betaRRR), ncol=models[[1]]$ny)
for(i in 1:length(betaRRR)){
  comp1_post[i,]=models[[1]]$XRRR %*% as.matrix((wRRR_post[i,1,]))
}

beta_comp1_post=NULL
for(i in 1:1000){
  beta_comp1_post[i]=betaRRR[i]*sd(comp1_post[i,])
}

resmat_RRR[nrow(resmat_RRR)+1,]=c("NA","NA","NA", 
                 round(mean(beta_comp1_post), 3),
                 round(quantile(beta_comp1_post, c(0.025)), 3),
                 round(quantile(beta_comp1_post, c(0.975)), 3),
                 "NA", "NA","NA")

kable(resmat_RRR)
```
#Obtain selection gradients for HMSC model "m1" (only includes phenotypic traits)

```{r, echo=FALSE}

nX = ncol(models[[2]]$XData)

#beta_raw_post = post$Beta[,2:(nX+1)][[1]] #posterior for betas
beta_raw_post = post1$Beta[,2:(5+1)][[1]]

head(beta_raw_post)

beta_var_post = matrix(NA, nrow=nrow(beta_raw_post), ncol=nX)
for(i in 1:nX){
  beta_var_post[,i] = beta_raw_post[,i]*sd(XData[,i])
}

beta_mean_post = matrix(NA, nrow=nrow(beta_raw_post), ncol=nX)
for(i in 1:nX){
  beta_mean_post[,i] = beta_raw_post[,i]*mean(XData[,i])
}

beta_raw = apply(beta_raw_post, 2, mean)
beta_raw_lower = apply(beta_raw_post, 2, quantile, c(0.025))
beta_raw_upper = apply(beta_raw_post, 2, quantile, c(0.975))

beta_var = apply(beta_var_post, 2, mean)
beta_var_lower = apply(beta_var_post, 2, quantile, c(0.025))
beta_var_upper = apply(beta_var_post, 2, quantile, c(0.975))

beta_mean = apply(beta_mean_post, 2, mean)
beta_mean_lower = apply(beta_mean_post, 2, quantile, c(0.025))
beta_mean_upper = apply(beta_mean_post, 2, quantile, c(0.975))


resmat_M1 = data.frame(beta_raw = round(beta_raw, 3),
                        L = round(beta_raw_lower, 3),
                        U = round(beta_raw_upper, 3),
                        beta_var = round(beta_var, 3),
                        L = round(beta_var_lower, 3),
                        U = round(beta_var_upper, 3),
                        beta_mean = round(beta_mean*100, 3),
                        L = round(beta_mean_lower, 3),
                        U = round(beta_mean_upper, 3))

#resmat_M1[nrow(resmat_M1)+1,]= rep(c("NA"), times= 9)


kable(resmat_M1)
```

#Selection gradients for HMSC model "m2" (includes phenotypic traits and each co-flowering species as standard predictors)
```{r, echo=FALSE}
nX = ncol(models[[3]]$XData)

beta_raw_post = post2$Beta[,2:(5+1)][[1]] #posterior for betas

beta_var_post = matrix(NA, nrow=nrow(beta_raw_post), ncol=ncol(beta_raw_post))
  for(i in 1:ncol(beta_raw_post)){
    beta_var_post[,i] = beta_raw_post[,i]*sd(models[[3]]$XData[,i])
  }
  
  beta_mean_post = matrix(NA, nrow=nrow(beta_raw_post), ncol=ncol(beta_raw_post))
  for(i in 1:ncol(beta_raw_post)){
    beta_mean_post[,i] = beta_raw_post[,i]*mean(models[[3]]$XData[,i])
  }

beta_raw = apply(beta_raw_post, 2, mean)
beta_raw_lower = apply(beta_raw_post, 2, quantile, c(0.025))
beta_raw_upper = apply(beta_raw_post, 2, quantile, c(0.975))

beta_var = apply(beta_var_post, 2, mean)
beta_var_lower = apply(beta_var_post, 2, quantile, c(0.025))
beta_var_upper = apply(beta_var_post, 2, quantile, c(0.975))

beta_mean = apply(beta_mean_post, 2, mean)
beta_mean_lower = apply(beta_mean_post, 2, quantile, c(0.025))
beta_mean_upper = apply(beta_mean_post, 2, quantile, c(0.975))


resmat_M2 = data.frame(beta_raw = round(beta_raw, 3),
                        L = round(beta_raw_lower, 3),
                        U = round(beta_raw_upper, 3),
                        beta_var = round(beta_var, 3),
                        L = round(beta_var_lower, 3),
                        U = round(beta_var_upper, 3),
                        beta_mean = round(beta_mean*100, 3),
                        L = round(beta_mean_lower, 3),
                        U = round(beta_mean_upper, 3))
#resmat_M2[nrow(resmat_M2)+1,]= rep(c("NA"), times= 9)

kable(resmat_M2)
```


#Selection gradients for HMSC model "m3" (includes the traits and RRR on nonanimal-pollinated co-flowering species)

```{r, echo=FALSE}
nX = ncol(models[[4]]$XData)

beta_raw_post = post3$Beta[,2:(5+1)][[1]]

beta_var_post = matrix(NA, nrow=nrow(beta_raw_post), ncol=nX)
for(i in 1:nX){
  beta_var_post[,i] = beta_raw_post[,i]*sd(XData[,i])
}

beta_mean_post = matrix(NA, nrow=nrow(beta_raw_post), ncol=nX)
for(i in 1:nX){
  beta_mean_post[,i] = beta_raw_post[,i]*mean(XData[,i])
}

beta_raw = apply(beta_raw_post, 2, mean)
beta_raw_lower = apply(beta_raw_post, 2, quantile, c(0.025))
beta_raw_upper = apply(beta_raw_post, 2, quantile, c(0.975))

beta_var = apply(beta_var_post, 2, mean)
beta_var_lower = apply(beta_var_post, 2, quantile, c(0.025))
beta_var_upper = apply(beta_var_post, 2, quantile, c(0.975))

beta_mean = apply(beta_mean_post, 2, mean)
beta_mean_lower = apply(beta_mean_post, 2, quantile, c(0.025))
beta_mean_upper = apply(beta_mean_post, 2, quantile, c(0.975))

resmat_M3 = data.frame(beta_raw = round(beta_raw, 3),
                        L = round(beta_raw_lower, 3),
                        U = round(beta_raw_upper, 3),
                        beta_var = round(beta_var, 3),
                        L = round(beta_var_lower, 3),
                        U = round(beta_var_upper, 3),
                        beta_mean = round(beta_mean*100, 3),
                        L = round(beta_mean_lower, 3),
                        U = round(beta_mean_upper, 3))

#resmat_M3[nrow(resmat_M3)+1,]= rep(c("NA"), times= 9)

kable(resmat_M3)
```

#Adding Beta for RRR non-animal-pollinated community axis.
```{r, echo=FALSE}

betaRRR = post3$Beta[,(nX+2):(models[[4]]$ncRRR+(nX+1))][[1]] #posterior for beta_RRR
#betaRRR = post$Beta[,(5+2):(m$ncRRR+(5+1))][[1]] #posterior for beta_RRR

## The non-anim-pollinated co-flowering community axis"
dim(models[[4]]$XRRR)

# Temp. posterior of wRRR
bind0 = function(...) {abind(..., along = 0)}
postList = poolMcmcChains(models[[4]]$postList, chainIndex = 1:length(models[[4]]$postList), 
                          start = 1, thin = 1)
valList = lapply(postList, function(a) a[["wRRR"]])
wRRR_postn = do.call(bind0, valList)


comp1_post = matrix(NA, nrow=length(betaRRR), ncol=models[[4]]$ny)
for(i in 1:length(betaRRR)){
  comp1_post[i,]=models[[4]]$XRRR %*% as.matrix((wRRR_postn[i,1,]))
}

beta_comp1_post=NULL
for(i in 1:1000){
  beta_comp1_post[i]=betaRRR[i]*sd(comp1_post[i,])
}

resmat_M3[nrow(resmat_M3)+1,]=c("NA","NA","NA", 
                 round(mean(beta_comp1_post), 3),
                 round(quantile(beta_comp1_post, c(0.025)), 3),
                 round(quantile(beta_comp1_post, c(0.975)), 3),
                 "NA","NA","NA")

kable(resmat_M3)
#The sign of the community axis is arbitrary (here "negative" for the non-animal-pollinated species, so multiply by "-1" for the sake of interpretation )
```

#Save betas from each model
```{r, echo=FALSE}
beta_pol_lap= list(resmat_RRR, resmat_M1, resmat_M2, resmat_M3)

#save(beta_pol_lap, file="analyses/betas_poll_lap.RData")

load(file= "analyses/betas_poll_lap.RData")
```

#Save data to use in post-hoc models
```{r, echo=FALSE}
Xmat= as.matrix(models[[1]]$XData)    
Yvec= as.numeric(models[[1]]$Y)  

# Center and scale traits
Xc= scale(Xmat, center = TRUE, scale = TRUE)
traits_names= colnames(Xc)

all_models.plap= list()

for(i in seq_along(models)) {
  m= models[[i]]
  
  # Check if model has RRR and it is not NULL
  if("XRRRData" %in% names(m) && !is.null(m$XRRRData)) {
    XRRRmat= scale(as.matrix(m$XRRRData), center = TRUE, scale = TRUE)
    hasRRR= TRUE
  } else {
    XRRRmat= NA
    hasRRR= FALSE
  }
  
  # Store 
  all_models.plap[[i]]= list(
    mcmc = m,
    XData = Xmat,              
    XRRRDataScaled = XRRRmat,
    Y = Yvec,                   
    hasRRR = hasRRR
  )
}

#saveRDS(all_models.plap, "analyses/models.poll_lap_fulldata.rds")
```

#Testing for an interaction between co-flowering community axis and selection (Table S6)

#Run a post-hoc model over all the posterior samples of the community axis from the HMSC model "m" and each phenotypic trait

```{r, echo=FALSE}
all_models.plap= readRDS("analyses/models.poll_lap_fulldata.rds")

model= all_models.plap[[1]]

# Ensure model has RRR
if(!model$hasRRR) stop("This model has no RRR data!")

XRRRmat= as.matrix(model$XRRRDataScaled)
Xmat= as.matrix(model$XData)
traits_names= make.names(colnames(Xmat))
Y= as.numeric(model$Y)
Xc= scale(Xmat)

# Posterior weights
postList= poolMcmcChains(model$mcmc$postList,
                           chainIndex = 1:length(model$mcmc$postList),
                           start = 1, thin = 1)

bind0= function(...) abind(..., along = 0)
valList= lapply(postList, function(a) a[["wRRR"]])
wRRR_post= do.call(bind0, valList)
nSamples= dim(wRRR_post)[1]

# Compute RRR axes
nInd= nrow(XRRRmat)
rrr_post_plap= matrix(NA, nrow = nInd, ncol = nSamples)

for(s in seq_len(nSamples)){
  w_vec= wRRR_post[s, 1, ]
  if(is.null(w_vec)) next
  rrr_post_plap[, s]= XRRRmat %*% as.numeric(w_vec)
}

# Coefficient storage
coef_names= c("(Intercept)", paste0("trait_", traits_names), "axis", paste0("int_", traits_names))
coef_store= matrix(NA, nrow = nSamples, ncol = length(coef_names), dimnames = list(NULL, coef_names))

# Fit regressions for each posterior sample
for(s in seq_len(nSamples)){
  axis_s= rrr_post_plap[, s]
  if(all(is.na(axis_s))) next
  axis_s_c= as.numeric(scale(axis_s))

  df= data.frame(Y = Y, axis = axis_s_c, Xc)
  
  for(tr in traits_names){
    df[[paste0("I_", tr, "_axis")]] <- df[[tr]] * df$axis
  }

  main_terms= paste(traits_names, collapse = " + ")
  inter_terms= paste(paste0("I_", traits_names, "_axis"), collapse = " + ")
  form= as.formula(paste0("Y ~ ", main_terms, " + axis + ", inter_terms))

  fit= tryCatch(lm(form, data = df), error = function(e) NULL)
  if(is.null(fit)) next
  
  coefs= coef(fit)
  coef_store[s, "(Intercept)"]= if(!is.null(coefs["(Intercept)"])) coefs["(Intercept)"] else NA
  coef_store[s, "axis"]= if(!is.null(coefs["axis"])) coefs["axis"] else NA

  for(tr in traits_names){
    trait_name= paste0("trait_", tr)
    int_name= paste0("int_", tr)
    inter_term= paste0("I_", tr, "_axis")
    coef_store[s, trait_name]= if(!is.null(coefs[tr])) coefs[tr] else NA
    coef_store[s, int_name]= if(!is.null(coefs[inter_term])) coefs[inter_term] else NA
  }
}

# Summarize posterior coefficients
summ= data.frame(
  term = coef_names,
  mean = apply(coef_store, 2, mean, na.rm = TRUE),
  median = apply(coef_store, 2, median, na.rm = TRUE),
  ci_lower = apply(coef_store, 2, quantile, probs = 0.025, na.rm = TRUE),
  ci_upper = apply(coef_store, 2, quantile, probs = 0.975, na.rm = TRUE),
  p_pos = apply(coef_store, 2, function(x) mean(x > 0, na.rm = TRUE)),
  p_neg = apply(coef_store, 2, function(x) mean(x < 0, na.rm = TRUE)),
  stringsAsFactors = FALSE
)

summ$postsup= apply(coef_store, 2, function(x){
  ps= mean(x > 0, na.rm = TRUE)
  if(is.na(ps)) return(NA_real_)
  if(ps < 0.5) ps <- 1 - ps
  return(ps)
})

print(summ)#Table S6
```

#Testing for realized environmental correlations: Table S5

#We use the RRR community axis derived from our main model "m" and calculate its correlation with phenotypic traits
```{r, echo=FALSE}
wRRR = getPostEstimate(models[[1]], "wRRR")

rrr = as.matrix(models[[1]]$XRRRData) %*% t(as.matrix(wRRR$mean))# the community axis

names(models[[1]]$XData)#the phenotypic traits

cor.plap = cor(rrr[,1], models[[1]]$XData)
cor.plap

```
#Co-flowering species weights: contribution of each animal-pollinated species to the composite community axis

```{r, echo=FALSE}
par(mar = c(4, 12, 2, 2), xpd = TRUE)

# Order species by mean weight
ord= order(wRRR$mean, decreasing = FALSE)

out= barplot(wRRR$mean[ord],
               horiz = TRUE,
               col = "darkgrey",
               xlim = c(-3, 2),
               las = 1,
               xlab = "Co-flowering species weights")

species_labels= gsub("_", " ", colnames(XRRRData)[ord])

species_expr= parse(text = paste0("italic('", species_labels, "')"))

text(x = -3.1, y = out,
     labels = species_expr,
     adj = 1, cex = 0.6)
```
#We can also calculate the corresponding slopes for the original variables (each animal-pollinated co-flowering species)

```{r, echo=FALSE}

betapost = post$Beta[,6:(models[[1]]$ncRRR+5)][[1]] #posterior for beta_RRR

beta_raw_post = matrix(NA, nrow=length(betapost), ncol=models[[1]]$ncORRR)
for(i in 1:length(betapost)){
  beta_raw_post[i,] = t(as.matrix(wRRR_post[i,,])) * betapost[i] 
}

beta_var_post = matrix(NA, nrow=length(betapost), ncol=models[[1]]$ncORRR)
for(i in 1:models[[1]]$ncORRR){
  beta_var_post[,i] = beta_raw_post[,i]*sd(models[[1]]$XRRRData[,i])
}

# Compute beta = wA for each posterior sample

# Alternative if XRRRData scaled before model fitting

beta_mean_post = matrix(NA, nrow=length(betapost), ncol=models[[1]]$ncORRR)
for(i in 1:models[[1]]$ncORRR){
  beta_mean_post[,i] = beta_raw_post[,i]*(mean(XRRRData[,i])/sd(XRRRData[,i]))
}

beta_raw = apply(beta_raw_post, 2, mean)
beta_raw_lower = apply(beta_raw_post, 2, quantile, c(0.025))
beta_raw_upper = apply(beta_raw_post, 2, quantile, c(0.975))

beta_var = apply(beta_var_post, 2, mean)
beta_var_lower = apply(beta_var_post, 2, quantile, c(0.025))
beta_var_upper = apply(beta_var_post, 2, quantile, c(0.975))

beta_mean = apply(beta_mean_post, 2, mean)
beta_mean_lower = apply(beta_mean_post, 2, quantile, c(0.025))
beta_mean_upper = apply(beta_mean_post, 2, quantile, c(0.975))

betamat_RRR = data.frame(beta_raw = round(beta_raw, 3),
                         lower = round(beta_raw_lower, 3),
                         upper = round(beta_raw_upper, 3),
                         beta_var = round(beta_var, 3),
                         lower = round(beta_var_lower, 3),
                         upper = round(beta_var_upper, 3),
                         beta_mean = round(beta_mean*100, 3),
                         L = round(beta_mean_lower*100, 3),
                         U = round(beta_mean_upper*100, 3))
rownames(betamat_RRR) = colnames(models[[1]]$XRRRData)

head(betamat_RRR)
```


```{r, echo=FALSE}
betamat_plot= betamat_RRR
betamat_plot$species= rownames(betamat_RRR)

str(betamat_plot)

ggplot(betamat_plot, aes(x = reorder(species, beta_var), y = beta_var)) +
  geom_point() +
  geom_errorbar(aes(ymin = lower.1, ymax = upper.1), width = 0.2) +
  coord_flip() +
  labs(x = "Co-flowering species", y = "Variance-scaled B",
       title = "Slopes for original variables (co-flowering species)") +
  theme_minimal()

```




```{r, echo=FALSE}
betamat_RRR= betamat_RRR[order(betamat_RRR$beta_var, decreasing = TRUE), ]

head(betamat_RRR)

```
#Plot the relationship between the RRR community axis and the response (relative poll. success)

```{r, echo=FALSE}
wRRR= getPostEstimate(models[[1]], "wRRR")

# Project predictors onto the RRR axis
rrr= as.matrix(models[[1]]$XRRRData) %*% t(as.matrix(wRRR$mean))
com.axis= rrr[, 1] 

# Response (first column of Y)
response= models[[1]]$Y[, 1]

plot(com.axis, response,
     pch = 19, col = "royalblue",
     xlab = "community axis",
     ylab = "Relative fitness")
```





```{r, echo=FALSE}
# Temp. posterior of wRRR
bind0 = function(...) {abind(..., along = 0)}
postList = poolMcmcChains(m_all$postList, chainIndex = 1:length(m_all$postList), 
                          start = 1, thin = 1)
valList = lapply(postList, function(a) a[["wRRR"]])
wRRR_post = do.call(bind0, valList)

dim(wRRR_post)

for(i in 1:30){
  plot(wRRR_post[,1,i], type="l")
}

##################
```


```{r, echo=FALSE}
m_all$XData

m_all$XRRRData

nX = ncol(m_all$XData)
nX

#beta_raw_post = post$Beta[,2:(nX+1)][[1]] #posterior for betas
beta_raw_post = post$Beta[,2:(5+1)][[1]]
head(beta_raw_post)

beta_var_post = matrix(NA, nrow=nrow(beta_raw_post), ncol=nX)
for(i in 1:nX){
  beta_var_post[,i] = beta_raw_post[,i]*sd(XData[,i])
}

beta_mean_post = matrix(NA, nrow=nrow(beta_raw_post), ncol=nX)
for(i in 1:nX){
  beta_mean_post[,i] = beta_raw_post[,i]*mean(XData[,i])
}

beta_raw = apply(beta_raw_post, 2, mean)
beta_raw_lower = apply(beta_raw_post, 2, quantile, c(0.025))
beta_raw_upper = apply(beta_raw_post, 2, quantile, c(0.975))

beta_var = apply(beta_var_post, 2, mean)
beta_var_lower = apply(beta_var_post, 2, quantile, c(0.025))
beta_var_upper = apply(beta_var_post, 2, quantile, c(0.975))

beta_mean = apply(beta_mean_post, 2, mean)
beta_mean_lower = apply(beta_mean_post, 2, quantile, c(0.025))
beta_mean_upper = apply(beta_mean_post, 2, quantile, c(0.975))

resmat_RRR = data.frame(beta_raw = round(beta_raw, 3),
                        L = round(beta_raw_lower, 3),
                        U = round(beta_raw_upper, 3),
                        beta_var = round(beta_var, 3),
                        L = round(beta_var_lower, 3),
                        U = round(beta_var_upper, 3),
                        beta_mean = round(beta_mean*100, 3),
                        L = round(beta_mean_lower, 3),
                        U = round(beta_mean_upper, 3))

betaRRR = post$Beta[,(nX+2):(models[[1]]$ncRRR+(nX+1))][[1]] #posterior for beta_RRR
#betaRRR = post$Beta[,(5+2):(m$ncRRR+(5+1))][[1]] #posterior for beta_RRR
length(betaRRR)

# The anim-pollinated co-flowering community axis"
dim(m_all$XRRR)

comp1_post = matrix(NA, nrow=length(betaRRR), ncol=m_all$ny)
for(i in 1:length(betaRRR)){
  comp1_post[i,]=m_all$XRRR %*% as.matrix((wRRR_post[i,1,]))
}

beta_comp1_post=NULL
for(i in 1:1000){
  beta_comp1_post[i]=betaRRR[i]*sd(comp1_post[i,])
}

resmat_RRR[nrow(resmat_RRR)+1,]=c("NA","NA","NA", 
                 round(mean(beta_comp1_post), 3),
                 round(quantile(beta_comp1_post, c(0.025)), 3),
                 round(quantile(beta_comp1_post, c(0.975)), 3),
                 "NA", "NA","NA")

kable(resmat_RRR)
```


```{r, echo=FALSE}
# Community axis
wRRR = getPostEstimate(models[[1]], "wRRR")
rrr = as.matrix(models[[1]]$XRRRData) %*% t(as.matrix(wRRR$mean))

com.axis= rrr[, 1]

Xrrr_raw= as.matrix(XRRRData)  # original unscaled abundances
#rrr <- Xrrr_raw %*% t(as.matrix(wRRR$mean))

species_names= colnames(Xrrr_raw)
n_species= ncol(Xrrr_raw)

# Layout: adjust rows/columns as needed
ncol_layout <- 2
nrow_layout <- ceiling(n_species / ncol_layout)
par(mfrow = c(nrow_layout, ncol_layout), mar = c(4, 4, 2, 1))

# Loop over species
for(i in 1:n_species){
  species_abun <- Xrrr_raw[, i]
  
  # Only positions where abundance > 0
  present <- which(species_abun > 0)
  
  # Plot empty canvas
  plot(range(com.axis), range(species_abun[present], 0), type = "n",
       xlab = "Community axis",
       ylab = "Abundance",
       main = species_names[i])
  
  # Draw vertical lines representing abundance
  if(length(present) > 0){
    segments(x0 = com.axis[present],
             y0 = 0,
             x1 = com.axis[present],
             y1 = species_abun[present],
             col = "darkgrey",
             lwd = 2)
  }
}


```

