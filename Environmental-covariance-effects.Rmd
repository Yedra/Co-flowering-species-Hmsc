---
title: "Community_effects_on_species_traits_analyses"
author: '"Yedra Garcia"'
date: "2023-12-09"
output: html_document
---

We are going to set up a model in HMSC to address the influence of micro-environmental variation on phenotypic traits of two food-deceptive orchids, which may indicate spurious trait-fitness correlations through environmental covariance effects. To do that, we use the surrounding animal-pollinated co-flowering community of each study orchid as a proxy of the micro-environment by applying a reduced-rank regression approach in HMSC.

Hence, we use the co-flowering community composition surrounding each study orchid as a proxy of the micro-environment experienced by that orchid species, which we would expect to influence its phenotype.


```{r,  echo= FALSE}
library(tidyverse)
library(Hmsc)
library(abind)
library(mgcv)
library(knitr)
library(ggplot2)
library(ggpubr)
```

#First for D. lapponica. Load merged data on phenotypic traits and the co-flowering community

```{r, echo= FALSE}
load(file= "analyses/alldata_lapp.RData")

indat= na.omit(all_data)
str(indat)
```

#Define the response variable Y, in this case, the phenotypic traits

```{r, echo=FALSE}

YData= indat[, c(2,6,7,8,10)]
Y= YData
Y$flowers_open= as.numeric(Y$flowers_open)
str(Y)

```

#Define the explanatory variable, here the co-flowering community: 

#We perform a reduced-rank regression on the animal-pollinated co-flowering species in the community
```{r}
#Select the animal-pollinated species in the co-flowering community from the data

# XRRRData obaject= the animal-pollinated co-flowering community

coflo_data= indat[, 19:73]

## Animal-pollinated co-flowering species

anim= c("Potentilla_erecta", "Primula_farinosa", "Pinguicula_vulgaris", "Succisa_pratensis", "Centaurea_jacea", "Prunella_grandiflora", "Prunella_vulgaris",
"Prunella_grandifloraxvulgaris", "Polygala_amarella", "Centarium_littorale", "Parnassia_palustris", "Antennaria_dioica", "Linum_catharticum", "Galium_boreale",
"Tetragonolobus_maritimus", "Scorzonera_humilis", "Tofieldia.calyculata", "Anthericum_ramosum", "Epipactis_palustris", "Platanthera_bifolia", "Gymnadenia_conopsea", "Gymnadenia_densiflora", "Gymnadenia_odoratissima", "Dactylorhiza_majalis_lapponica", "Inula.salicina", "Gentianella_uliginosa_cf", "Frangula_alnus_smallplant",
"Euphrasia_salisburgensis", "Vaccinium_vitis.idaea", "Asperula_tinctoria",
"Gymnadenia_sp", "Allium_schoenoprasum", "Leontodon_autumnalis", "Potentilla_reptans", "Calluna_vulgaris", "Dactylorhiza_incarnata_cruenta")

XRRRData = coflo_data[, colnames(coflo_data) %in% anim]
names(XRRRData)

XRRRData = XRRRData[, match(anim, colnames(XRRRData))]
dim(XRRRData)

XRRRData = XRRRData[, colSums(XRRRData>=1) >1]# remove singletons

XRRRDataScaled = data.frame(scale(XRRRData))# scale the community data
str(XRRRData)
```
#Define the model XFormula that includes the RRR for the co-flowering community as predictor

```{r}
XRRRFormula = as.formula(paste("~", " -1 + ", paste0(colnames(XRRRData), collapse=" + ")))
XRRRFormula
```

#We need to define XData (here just the intercept: vector of length= number of observations)
```{r}
XData= data.frame(intercept=rep(1,196))
XData
```

Define the HMSC model: 
```{r}
m = Hmsc(Y = as.matrix(Y), XData=XData, XFormula= ~1,
         distr= "normal", 
         XRRRData=XRRRDataScaled, XRRRFormula=XRRRFormula, ncRRR=1, XRRRScale = TRUE)
```

Set the model parameters:
```{r}
samples = 1500
thin = 100
transient = .5*(thin*samples)
adaptNf = 0.4*(thin*samples)
nChains = 1


mtraits_lap = sampleMcmc(m, samples = samples, thin = thin, adaptNf=rep(adaptNf, m$nr), 
                     transient = transient, nChains = nChains)

#save(mtraits_lap, file="analyses/model_comm-traits_lapp.RData")# including open flowers

load(file="analyses/model_comm-traits_lapp.RData")
```

#Check effective sample sizes
```{r}
#Effective sample size 
effectiveSize(post$Beta)
```

#MCMC convergence:

```{r}
post = convertToCodaObject(mtraits_lap)  
plot(post$Beta)
plot(post$Beta[, 1:10])
```

#Evaluate model fitting:
```{r}

predY = computePredictedValues(mtraits_lap)
MF = evaluateModelFit(mtraits_lap, predY)
round(MF$R2, 3)
round(mean(MF$R2), 3)#13.3% variance explained
```
#Get Beta parameters:
```{r}
pBeta = getPostEstimate(mtraits_lap, "Beta")
pBeta
```
#Posterior support for Betas:

```{r}
summary(post$Beta)

getPostEstimate(mtraits_lap, "Beta")

postsup= getPostEstimate(mtraits_lap, "Beta")$support

postsup[which(postsup<0.5)] = 1 - postsup[which(postsup<0.5)]
postsup

```

#Second, for D. majalis. Load merged data on phenotypic traits and the co-flowering community

```{r}
load(file= "analyses/alldata_maj.RData")

indata= na.omit(all_mj)

indat= indata %>%
  filter(!Patch== "E")%>%
  droplevels()##104 individuals

names(indat)
```

#Define the Y response variable, the phenotypic traits
```{r}

YData= indat[, c(6:9)]
Y= YData
Y$flowers_open= as.numeric(Y$flowers_open)

head(Y)
```

#Set random effects: To account for potential non-spatial independence in D. majalis samples, we include Patch as a random factor in the model
```{r, echo=FALSE}
study.Design= data.frame(patch= indat$Patch)
study.Design$patch= as.factor(study.Design$patch)

head(study.Design)
```

#Define the explanatory variable, here the co-flowering community: 

#We will perform a reduced-rank regression of the animal-pollinated co-flowering species to test for co-flowering community effects on D. lapponica traits.

```{r}
#Select the animal-pollinated species in the co-flowering community from the data

# XRRRData obaject= the animal-pollinated co-flowering community

coflo_data= indat[, c(19:26, 28:30)]

XRRRData= coflo_data

XRRRData = XRRRData[, colSums(XRRRData>=1) >1]

XRRRDataScaled = data.frame(scale(XRRRData))

names(XRRRData)
```

Define the model XFormula that includes the RRR for the co-flowering community as predictor

```{r}
XRRRFormula = as.formula(paste("~", " -1 + ", paste0(colnames(XRRRData), collapse=" + ")))
XRRRFormula

XData= data.frame(intercept=rep(1,104))
XData
```

Define the HMSC model: 
```{r}
mr = Hmsc(Y = as.matrix(Y), XData=XData, XFormula= ~1,
         XRRRData=XRRRDataScaled, XRRRFormula=XRRRFormula, ncRRR=1, XRRRScale = TRUE,
         studyDesign = study.Design, ranLevels = list("patch"= rL), distr= "normal")

```

Set model parameters:
```{r}
samples = 1000
thin = 100
transient = .5*(thin*samples)
adaptNf = 0.4*(thin*samples)
nChains = 1


mtraits_maj = sampleMcmc(mr, samples = samples, thin = thin, adaptNf=rep(adaptNf, mr$nr), 
                     transient = transient, nChains = nChains)

#save(mtraits_maj, file="analyses/model_comm-traits_maj.RData")# including open flowers
```

#MCMC convergence:

```{r}
load(file="analyses/model_comm-traits_maj.RData")

post = convertToCodaObject(mtraits_maj)

plot(post$Beta[, 1:6])
```

#Check effective sample size:

```{r}
#Effective sample size 
effectiveSize(post$Beta)
```

#Evaluate model fitting:
```{r}
predY = computePredictedValues(mtraits_maj)
MF = evaluateModelFit(mtraits_maj, predY)
round(MF$R2, 3)
round(mean(MF$R2), 3)#10.7% variance explained
```

#Get Beta parameters:
```{r}
summary(post$Beta)

pBeta = getPostEstimate(mtraits_maj, "Beta")
pBeta

```

#Posterior support for Betas:

```{r}
getPostEstimate(mtraits_maj, "Beta")

postsup= getPostEstimate(mtraits_maj, "Beta")$support

postsup[which(postsup<0.5)] = 1 - postsup[which(postsup<0.5)]
postsup
```




