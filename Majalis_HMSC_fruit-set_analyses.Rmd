---
title: 'D. majalis: Selection analyses via fruit set'
author: '"Yedra Garcia"'
date: "2023-12-09"
output: html_document
---

```{r, eval=FALSE}

library(tidyverse)
library(Hmsc)
library(abind)
library(mgcv)
library(knitr)
library(ggplot2)
library(reshape2)
library(data.table)
library(ggpubr)
```
#Loading trait, fitness, co-flowering community and animal-pollspecies data


```{r}
traitdata_kn= read.csv("data/data_CRO/Complete_KN_traitdata.csv", header=T, sep= ";", dec=",") %>% mutate(individual= as.character(individual))

commudata_kn= read.csv("data/data_CRO/Complete_KN_communitydata.csv", header= T, sep= ";", fileEncoding="latin1")%>% mutate(individual= as.character(individual))

traitdata_kn= traitdata_kn%>%
  select(-c(2,10,12))%>% rename(height= height_cm, flower_size= flower_size_mm, spur_length= spur_length_mm,
                                flowers_open= flowers_open, flowers= No_of_flowers) 
names(traitdata_kn)
```

#Average traits at the plant level and filter outliers
```{r pressure, echo=FALSE}
traitdata_knb<- traitdata_kn %>% 
  group_by(individual, Patch, Species, Site, Period) %>% 
  summarise_at(vars(height:flowers), funs(mean), na.rm=TRUE)%>% 
  ungroup()

# Check for outliers
traitdata_knb_mj= traitdata_knb %>%
  filter(Species== "MJ" & Period== "early")%>%
  droplevels()

hist(traitdata_knb_mj$height)

traitdata_knb_mj= traitdata_knb_mj%>% filter(height <= 30)
```

#Community data
```{r pressure, echo=FALSE}

commudata_kn= commudata_kn %>% select(-c(14,15))%>% rename(Patch= "patch")# 2 columns with only presence absence data

commudata_mj= commudata_kn%>%
  filter(Species== "MJ" & Period== "early")%>%
  droplevels()

```

#Merge community and trai-fitness data
```{r}
all_mjf<-merge(traitdata_knb_mj, commudata_mj, by= c("individual", "Species", "Period", "Patch"), all.x= TRUE)

#save(all_mjf, file = "analyses/alldatafruit_maj.RData")

```
#HMSC

```{r}
indat= na.omit(all_mjf)

indat= indat %>%
  filter(!Patch== "E")%>%# 103 individuals with information on fruit number
  droplevels()
```

#Set random effects:Defining Patch as a random factor in the model
```{r, echo=FALSE}
study.Design= data.frame(patch= indat$Patch)
study.Design$patch= as.factor(study.Design$patch)
head(study.Design)
```

#Define response= fitness variable: fruit number
```{r, echo=FALSE}

Y= cbind(indat$fruit_number)
head(Y)
hist(Y)
```

#Defina the standard predictors XData (traits)
```{r, echo=FALSE}
XData= indat[, c(6:8, 10)]
head(XData)
```
#Define the co-flowering community

```{r, echo=FALSE}
coflo_data= indat[, c(13:20, 22:24)]# co-flowering species (exclude var "Dactylorhiza_3m", corresponds with conspecific density)
XRRRData= coflo_data

XRRRData = XRRRData[,colSums(XRRRData>=1) >1]#without singletons
names(XRRRData)
```

Define the Xformula with the trait predictors (= XData)
```{r, echo=FALSE}
XFormula = as.formula(paste("~", paste0(colnames(XData), collapse=" + ")))
XFormula
```
Define the XRRRformula with the animal-pollinated species (= XRRRData) 

```{r, echo=FALSE}
XRRRFormula = as.formula(paste("~", " -1 + ", paste0(colnames(XRRRData), collapse=" + ")))
XRRRFormula
```

#Scale the XRRRData (the animal-poll co-flowering community)
```{r, echo=FALSE}
XRRRDataScaled = data.frame(scale(XRRRData))
dim(XRRRData)
```

Fit the HMSC models.In this case all models include Patch as a random factor

Define Patch as random factor in the models

```{r}
rL = HmscRandomLevel(units = unique(study.Design$patch))
```

#HMSC with traits and the RRR of the animal-pollinated species as predictors (m)

```{r, echo=FALSE}

m = Hmsc(Y = as.matrix(Y/mean(Y)), XData=XData, XFormula=XFormula,
         XRRRData=XRRRDataScaled, XRRRFormula=XRRRFormula, ncRRR=1, XRRRScale = TRUE,
         studyDesign = study.Design, ranLevels = list("patch"= rL),  distr= "normal")
m
```
#Alternative models:

#HMSC only with traits as predictors (m1)

```{r, eval=FALSE}
m1 = Hmsc(Y = as.matrix(Y/mean(Y)), XData=XData, XFormula=XFormula, studyDesign = study.Design, ranLevels = list("patch"= rL),
          distr="normal")
m1
```
#HMSC with traits and each animal-pollinated species as predictors (m2)

Here, we need another XData object (= XData2) that includes the traits and each animal-poll co-flowering species (XRRRData) and define an Xformula for it (= XFormula2)
```{r}

XData2 = data.frame(XData, XRRRData)
XFormula2 = as.formula(paste("~", paste0(colnames(XData2), collapse=" + ")))
XFormula2
```
The model:
```{r, echo==FALSE}
m2 = Hmsc(Y = as.matrix(Y/mean(Y)), XData=XData2, XFormula=XFormula2, studyDesign = study.Design, ranLevels = list("patch"= rL),
          distr="normal")
m2
```

Now we set the sampling parameters and fit the three models.

```{r, echo=FALSE}
samples = 1000
thin = 100
transient = .5*(thin*samples)
adaptNf = 0.4*(thin*samples)
nChains = 1

models= list(m, m1, m2)
for(i in 1:3){
  models[[i]]= sampleMcmc(models[[i]], samples = samples, thin = thin, adaptNf=rep(adaptNf, m$nr), 
               transient = transient, nChains = nChains)}

#save(models, file ="analyses/models_fset_maj.RData")

load(file ="analyses/models_fset_maj.RData")
```


```{r, echo=FALSE}

mo = Hmsc(Y = as.matrix(Y/mean(Y)), XData=XData, XFormula=XFormula,
         XRRRData=XRRRDataScaled, XRRRFormula=XRRRFormula, ncRRR=1, XRRRScale = TRUE,
         distr= "normal")
mo

mo= sampleMcmc(mo, samples = samples, thin = thin, adaptNf=rep(adaptNf, mo$nr), 
               transient = transient, nChains = nChains)

save(mo, file ="analyses/models_fset-norand_maj.RData")

postm= convertToCodaObject(mo, covNamesNumbers = c(T,F))

effectiveSize(postm$Beta)

pred= computePredictedValues(mo)
MF= evaluateModelFit(hM= mo, predY = pred)
MF#37.77 without patch as random factor

```

Check effective sample sizes
```{r, echo=FALSE}
post= convertToCodaObject(models[[1]], covNamesNumbers = c(T,F))
post1= convertToCodaObject(models[[2]], covNamesNumbers = c(T,F))
post2= convertToCodaObject(models[[3]], covNamesNumbers = c(T,F))

effectiveSize(post$Beta)
```

#MCMC convergence

```{r, echo=FALSE}
plot(post$Beta[,6])
```

# Temp. posterior of wRRR
```{r, echo=FALSE}
# Temp. posterior of wRRR
bind0 = function(...) {abind(..., along = 0)}
postList = poolMcmcChains(models[[1]]$postList, chainIndex = 1:length(models[[1]]$postList), 
                          start = 1, thin = 1)
valList = lapply(postList, function(a) a[["wRRR"]])
wRRR_post = do.call(bind0, valList)

dim(wRRR_post)

for(i in 1:8){
  plot(wRRR_post[,1,i], type="l")
}
```

#Posterior support for Betas

```{r, echo=FALSE}
getPostEstimate(models[[1]], "Beta")

postsup= getPostEstimate(models[[1]], "Beta")$support[2:6, ]

postsup[which(postsup<0.5)] = 1 - postsup[which(postsup<0.5)]
postsup
```

#Model fitting

Now we evaluate the explanatory power of the model "m" by computing the R^2 values and compare with alternative models (m1, and m2)
```{r, echo=FALSE}
MF_results= matrix(NA, nrow= 2, ncol= 3)
for(i in 1:3){
  m= models[[i]]
  pred= computePredictedValues(m)
        MF= evaluateModelFit(hM= m, predY = pred)
        MF_results[1,i]= mean(MF$R2)
}

MF_results
```

Now we evaluate the predictive power of the model "m" and of the alternative models by using 5-fold cross validation

```{r, echo=FALSE}
partition= createPartition(m, nfolds=5)

for(i in 1:3){
  m= models[[i]]
  pred_CV = computePredictedValues(m, partition)
  MF_CV= evaluateModelFit(hM= m, predY = pred_CV)
  MF_results[2, i]= mean(MF_CV$R2)
}

MF_results

colnames(MF_results)= c("RRRco", "MR", "MRco")
rownames(MF_results)=  c("MF", "MF_cV")

MF_results= as.data.frame(MF_results)

save(MF_results, file="results/MF_fset_maj.RData")

MF_results
```
#Obtain the selection gradients for m


```{r, echo=FALSE}
nX = ncol(models[[1]]$XData)
nX

#beta_raw_post = post$Beta[,2:(nX+1)][[1]] #posterior for betas
beta_raw_post = post$Beta[,2:(4+1)][[1]]
head(beta_raw_post)

beta_var_post = matrix(NA, nrow=nrow(beta_raw_post), ncol=nX)
for(i in 1:nX){
  beta_var_post[,i] = beta_raw_post[,i]*sd(XData[,i])
}

beta_mean_post = matrix(NA, nrow=nrow(beta_raw_post), ncol=nX)
for(i in 1:nX){
  beta_mean_post[,i] = beta_raw_post[,i]*mean(XData[,i])
}

beta_raw = apply(beta_raw_post, 2, mean)
beta_raw_lower = apply(beta_raw_post, 2, quantile, c(0.025))
beta_raw_upper = apply(beta_raw_post, 2, quantile, c(0.975))

beta_var = apply(beta_var_post, 2, mean)
beta_var_lower = apply(beta_var_post, 2, quantile, c(0.025))
beta_var_upper = apply(beta_var_post, 2, quantile, c(0.975))

beta_mean = apply(beta_mean_post, 2, mean)
beta_mean_lower = apply(beta_mean_post, 2, quantile, c(0.025))
beta_mean_upper = apply(beta_mean_post, 2, quantile, c(0.975))

resmat_RRR = data.frame(beta_raw = round(beta_raw, 3),
                        L = round(beta_raw_lower, 3),
                        U = round(beta_raw_upper, 3),
                        beta_var = round(beta_var, 3),
                        L = round(beta_var_lower, 3),
                        U = round(beta_var_upper, 3),
                        beta_mean = round(beta_mean*100, 3),
                        L = round(beta_mean_lower, 3),
                        U = round(beta_mean_upper, 3))

betaRRR = post$Beta[,(nX+2):(models[[1]]$ncRRR+(nX+1))][[1]] #posterior for beta_RRR
#betaRRR = post$Beta[,(5+2):(m$ncRRR+(5+1))][[1]] #posterior for beta_RRR
length(betaRRR)

# The anim-pollinated co-flowering community axis"
dim(models[[1]]$XRRR)

comp1_post = matrix(NA, nrow=length(betaRRR), ncol=models[[1]]$ny)
for(i in 1:length(betaRRR)){
  comp1_post[i,]=models[[1]]$XRRR %*% as.matrix((wRRR_post[i,1,]))
}

beta_comp1_post=NULL
for(i in 1:1000){
  beta_comp1_post[i]=betaRRR[i]*sd(comp1_post[i,])
}

resmat_RRR[nrow(resmat_RRR)+1,]=c("NA","NA","NA", 
                 round(mean(beta_comp1_post), 3),
                 round(quantile(beta_comp1_post, c(0.025)), 3),
                 round(quantile(beta_comp1_post, c(0.975)), 3),
                 "NA", "NA","NA")

kable(resmat_RRR)
```

#Obtain the selection gradients for m1

```{r, echo=FALSE}
nX = ncol(models[[2]]$XData)
nX

#beta_raw_post = post$Beta[,2:(nX+1)][[1]] #posterior for betas
beta_raw_post = post1$Beta[,2:(4+1)][[1]]

head(beta_raw_post)

beta_var_post = matrix(NA, nrow=nrow(beta_raw_post), ncol=nX)
for(i in 1:nX){
  beta_var_post[,i] = beta_raw_post[,i]*sd(XData[,i])
}

beta_mean_post = matrix(NA, nrow=nrow(beta_raw_post), ncol=nX)
for(i in 1:nX){
  beta_mean_post[,i] = beta_raw_post[,i]*mean(XData[,i])
}

beta_raw = apply(beta_raw_post, 2, mean)
beta_raw_lower = apply(beta_raw_post, 2, quantile, c(0.025))
beta_raw_upper = apply(beta_raw_post, 2, quantile, c(0.975))

beta_var = apply(beta_var_post, 2, mean)
beta_var_lower = apply(beta_var_post, 2, quantile, c(0.025))
beta_var_upper = apply(beta_var_post, 2, quantile, c(0.975))

beta_mean = apply(beta_mean_post, 2, mean)
beta_mean_lower = apply(beta_mean_post, 2, quantile, c(0.025))
beta_mean_upper = apply(beta_mean_post, 2, quantile, c(0.975))


resmat_M1 = data.frame(beta_raw = round(beta_raw, 3),
                        L = round(beta_raw_lower, 3),
                        U = round(beta_raw_upper, 3),
                        beta_var = round(beta_var, 3),
                        L = round(beta_var_lower, 3),
                        U = round(beta_var_upper, 3),
                        beta_mean = round(beta_mean*100, 3),
                        L = round(beta_mean_lower, 3),
                        U = round(beta_mean_upper, 3))

resmat_M1[nrow(resmat_M1)+1,]= rep(c("NA"), times= 9)


kable(resmat_M1)
```

#Selection gradients of m2


```{r, echo=FALSE}
nX = ncol(models[[3]]$XData)
nX

beta_raw_post = post2$Beta[,2:(4+1)][[1]] #posterior for betas
#beta_raw_post = post2$Beta[,2:(12+1)][[1]] 
head(beta_raw_post)

beta_var_post = matrix(NA, nrow=nrow(beta_raw_post), ncol=ncol(beta_raw_post))
  for(i in 1:ncol(beta_raw_post)){
    beta_var_post[,i] = beta_raw_post[,i]*sd(models[[3]]$XData[,i])
  }
  
  beta_mean_post = matrix(NA, nrow=nrow(beta_raw_post), ncol=ncol(beta_raw_post))
  for(i in 1:ncol(beta_raw_post)){
    beta_mean_post[,i] = beta_raw_post[,i]*mean(models[[3]]$XData[,i])
  }

beta_raw = apply(beta_raw_post, 2, mean)
beta_raw_lower = apply(beta_raw_post, 2, quantile, c(0.025))
beta_raw_upper = apply(beta_raw_post, 2, quantile, c(0.975))

beta_var = apply(beta_var_post, 2, mean)
beta_var_lower = apply(beta_var_post, 2, quantile, c(0.025))
beta_var_upper = apply(beta_var_post, 2, quantile, c(0.975))

beta_mean = apply(beta_mean_post, 2, mean)
beta_mean_lower = apply(beta_mean_post, 2, quantile, c(0.025))
beta_mean_upper = apply(beta_mean_post, 2, quantile, c(0.975))


resmat_M2 = data.frame(beta_raw = round(beta_raw, 3),
                        L = round(beta_raw_lower, 3),
                        U = round(beta_raw_upper, 3),
                        beta_var = round(beta_var, 3),
                        L = round(beta_var_lower, 3),
                        U = round(beta_var_upper, 3),
                        beta_mean = round(beta_mean*100, 3),
                        L = round(beta_mean_lower, 3),
                        U = round(beta_mean_upper, 3))
resmat_M2[nrow(resmat_M2)+1,]= rep(c("NA"), times= 9)

kable(resmat_M2)
```


```{r, echo=FALSE}

beta_fset_maj= list(resmat_RRR, resmat_M1, resmat_M2)

#save(beta_fset_maj, file= "analyses/betas_fset_maj.RData")

mods= c("RRRco", "MR", "MRco")

#Variance-scaled Betas

summary_var = matrix(NA, nrow = 5, ncol = length(mods))
for(i in 1:length(mods)){
  summary_var[,i] = round(as.numeric(beta_fset_maj[[i]]$beta_var), 3)
}

colnames(summary_var) = mods
rownames(summary_var) = rownames(beta_fset_maj[[1]])
summary_var = t(summary_var)
summary_var

upper_var = matrix(NA, nrow = 5, ncol = length(mods))
for(i in 1:length(mods)){
  upper_var[,i] = round(as.numeric(beta_fset_maj[[i]]$U.1), 3)
}

colnames(upper_var) = mods
rownames(upper_var) = rownames(beta_fset_maj[[1]])
upper_var = t(upper_var)
upper_var

lower_var = matrix(NA, nrow = 5, ncol = length(mods))
for(i in 1:length(mods)){
  lower_var[,i] = round(as.numeric(beta_fset_maj[[i]]$L.1), 3)
}

colnames(lower_var) = mods
rownames(lower_var) = rownames(beta_fset_maj[[1]])
lower_var = t(lower_var)

summary_var[,5] = summary_var[,5]*-1 
lower_var[,5] = lower_var[,5]*-1
upper_var[,5] = upper_var[,5]*-1
summary_var

bdf = data.frame(summary_var, lower_var, upper_var)
names(bdf)= c("B_PlantHeight", "B_FlwSize", "B_SpurLength", "B_FlwOpen", "B_community", rep("Lower", times=5), rep("Upper", times=5))

bdf <- cbind(model = rownames(bdf), bdf)

bdfm= melt(setDT(bdf), measure = patterns("^B", "^Lower", "^Upper"), value.name = c("Beta_var", "Lower", "Upper"), variable.name = "trait", variable.factor = "trait")

bdf2= bdfm %>% mutate(trait= recode(trait, "1"= "Plant height", "2"= "Flower size", "3"= "Spur length", "4"= "Open flowers", "5"= "Community"), model= factor(model, levels= c("RRRco", "MR", "MRco")))

VARplot_fset_maj= ggplot(bdf2, aes(x=model, y=Beta_var, colour=factor(model))) +
 geom_pointrange(aes(ymin = Lower, ymax = Upper), linetype = "solid", size=0.75)+
  #geom_errorbar(aes(ymin = Lower, ymax = Upper), width=.75) +
  labs(y= expression(beta ~ "Variance-scaled selection gradients"), x= expression(italic("Dactylorhiza majalis"), size=12))+
  scale_y_continuous(breaks = c(-0.50, -0.25, 0, 0.25, 0.50, 0.75, 1), limits=c(-0.50, 1))+
   facet_wrap(~ trait, nrow = 2L, strip.position = "top")+
  theme_bw(base_size = 15)+
  theme(text = element_text(size=15), axis.text.x= element_blank(),  axis.ticks.x = element_blank(), legend.title= element_blank(), panel.grid.major.x = element_blank(), panel.grid.minor.x = element_blank(), panel.grid.major.y = element_blank(), panel.grid.minor.y = element_blank(), strip.text = element_text(size=12), panel.background = element_blank())+
  geom_hline(yintercept=0, linetype="dashed", color = "black")

VARplot_fset_maj


```





